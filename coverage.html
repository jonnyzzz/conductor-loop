
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>conductor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jonnyzzz/conductor-loop/cmd/conductor/main.go (80.0%)</option>
				
				<option value="file1">github.com/jonnyzzz/conductor-loop/cmd/run-agent/main.go (91.3%)</option>
				
				<option value="file2">github.com/jonnyzzz/conductor-loop/internal/agent/claude/claude.go (83.0%)</option>
				
				<option value="file3">github.com/jonnyzzz/conductor-loop/internal/agent/codex/codex.go (85.0%)</option>
				
				<option value="file4">github.com/jonnyzzz/conductor-loop/internal/agent/executor.go (76.8%)</option>
				
				<option value="file5">github.com/jonnyzzz/conductor-loop/internal/agent/gemini/gemini.go (82.1%)</option>
				
				<option value="file6">github.com/jonnyzzz/conductor-loop/internal/agent/perplexity/perplexity.go (80.0%)</option>
				
				<option value="file7">github.com/jonnyzzz/conductor-loop/internal/agent/process_group_unix.go (80.0%)</option>
				
				<option value="file8">github.com/jonnyzzz/conductor-loop/internal/agent/stdio.go (84.6%)</option>
				
				<option value="file9">github.com/jonnyzzz/conductor-loop/internal/agent/xai/xai.go (83.2%)</option>
				
				<option value="file10">github.com/jonnyzzz/conductor-loop/internal/api/discovery.go (78.0%)</option>
				
				<option value="file11">github.com/jonnyzzz/conductor-loop/internal/api/handlers.go (76.7%)</option>
				
				<option value="file12">github.com/jonnyzzz/conductor-loop/internal/api/middleware.go (81.2%)</option>
				
				<option value="file13">github.com/jonnyzzz/conductor-loop/internal/api/routes.go (100.0%)</option>
				
				<option value="file14">github.com/jonnyzzz/conductor-loop/internal/api/server.go (93.0%)</option>
				
				<option value="file15">github.com/jonnyzzz/conductor-loop/internal/api/sse.go (81.7%)</option>
				
				<option value="file16">github.com/jonnyzzz/conductor-loop/internal/api/tailer.go (77.9%)</option>
				
				<option value="file17">github.com/jonnyzzz/conductor-loop/internal/config/api.go (92.9%)</option>
				
				<option value="file18">github.com/jonnyzzz/conductor-loop/internal/config/config.go (72.3%)</option>
				
				<option value="file19">github.com/jonnyzzz/conductor-loop/internal/config/storage.go (77.8%)</option>
				
				<option value="file20">github.com/jonnyzzz/conductor-loop/internal/config/tokens.go (88.1%)</option>
				
				<option value="file21">github.com/jonnyzzz/conductor-loop/internal/config/validation.go (73.0%)</option>
				
				<option value="file22">github.com/jonnyzzz/conductor-loop/internal/messagebus/lock.go (72.2%)</option>
				
				<option value="file23">github.com/jonnyzzz/conductor-loop/internal/messagebus/lock_unix.go (57.1%)</option>
				
				<option value="file24">github.com/jonnyzzz/conductor-loop/internal/messagebus/messagebus.go (83.8%)</option>
				
				<option value="file25">github.com/jonnyzzz/conductor-loop/internal/messagebus/msgid.go (100.0%)</option>
				
				<option value="file26">github.com/jonnyzzz/conductor-loop/internal/runner/job.go (77.6%)</option>
				
				<option value="file27">github.com/jonnyzzz/conductor-loop/internal/runner/orchestrator.go (83.3%)</option>
				
				<option value="file28">github.com/jonnyzzz/conductor-loop/internal/runner/pgid.go (100.0%)</option>
				
				<option value="file29">github.com/jonnyzzz/conductor-loop/internal/runner/pgid_unix.go (77.8%)</option>
				
				<option value="file30">github.com/jonnyzzz/conductor-loop/internal/runner/process.go (78.9%)</option>
				
				<option value="file31">github.com/jonnyzzz/conductor-loop/internal/runner/ralph.go (80.5%)</option>
				
				<option value="file32">github.com/jonnyzzz/conductor-loop/internal/runner/sleep.go (85.7%)</option>
				
				<option value="file33">github.com/jonnyzzz/conductor-loop/internal/runner/stdio.go (85.0%)</option>
				
				<option value="file34">github.com/jonnyzzz/conductor-loop/internal/runner/stop_unix.go (85.7%)</option>
				
				<option value="file35">github.com/jonnyzzz/conductor-loop/internal/runner/task.go (82.5%)</option>
				
				<option value="file36">github.com/jonnyzzz/conductor-loop/internal/runner/wait.go (77.0%)</option>
				
				<option value="file37">github.com/jonnyzzz/conductor-loop/internal/runner/wait_unix.go (70.0%)</option>
				
				<option value="file38">github.com/jonnyzzz/conductor-loop/internal/storage/atomic.go (70.2%)</option>
				
				<option value="file39">github.com/jonnyzzz/conductor-loop/internal/storage/storage.go (89.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/api"
        "github.com/jonnyzzz/conductor-loop/internal/config"
        "github.com/spf13/cobra"
)

const version = "dev"

func main() <span class="cov8" title="1">{
        if err := newRootCmd().Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func newRootCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                configPath       string
                rootDir          string
                disableTaskStart bool
        )

        cmd := &amp;cobra.Command{
                Use:          "conductor",
                Short:        "Conductor Loop orchestration CLI",
                Version:      version,
                SilenceUsage: true,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runServer(configPath, rootDir, disableTaskStart)
                }</span>,
        }
        <span class="cov8" title="1">cmd.SetVersionTemplate("{{.Version}}\n")

        cmd.Flags().StringVar(&amp;configPath, "config", "", "config file path")
        cmd.Flags().StringVar(&amp;rootDir, "root", "", "run-agent root directory")
        cmd.Flags().BoolVar(&amp;disableTaskStart, "disable-task-start", false, "disable task execution")

        cmd.AddCommand(newTaskCmd())
        cmd.AddCommand(newJobCmd())

        return cmd</span>
}

func newTaskCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "task",
                Short: "Manage tasks",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        cmd.Println("task command not implemented yet")
                }</span>,
        }
}

func newJobCmd() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "job",
                Short: "Manage jobs",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        cmd.Println("job command not implemented yet")
                }</span>,
        }
}

func runServer(configPath, rootDir string, disableTaskStart bool) error <span class="cov8" title="1">{
        logger := log.New(os.Stdout, "conductor ", log.LstdFlags)

        configPath = strings.TrimSpace(configPath)
        if configPath == "" </span><span class="cov8" title="1">{
                configPath = strings.TrimSpace(os.Getenv("CONDUCTOR_CONFIG"))
        }</span>
        <span class="cov8" title="1">rootDir = strings.TrimSpace(rootDir)
        if rootDir == "" </span><span class="cov8" title="1">{
                rootDir = strings.TrimSpace(os.Getenv("CONDUCTOR_ROOT"))
        }</span>
        <span class="cov8" title="1">if envDisable := strings.TrimSpace(os.Getenv("CONDUCTOR_DISABLE_TASK_START")); envDisable != "" </span><span class="cov8" title="1">{
                disableTaskStart = parseBool(envDisable)
        }</span>

        <span class="cov8" title="1">var (
                apiConfig config.APIConfig
                cfg       *config.Config
        )

        if configPath != "" </span><span class="cov8" title="1">{
                loaded, err := config.LoadConfigForServer(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("config load failed: %v (continuing with defaults)", err)
                        disableTaskStart = true
                }</span> else<span class="cov8" title="1"> {
                        cfg = loaded
                        apiConfig = loaded.API
                }</span>
        }

        <span class="cov8" title="1">if rootDir == "" &amp;&amp; cfg != nil </span><span class="cov8" title="1">{
                rootDir = strings.TrimSpace(cfg.Storage.RunsDir)
        }</span>

        <span class="cov8" title="1">server, err := api.NewServer(api.Options{
                RootDir:          rootDir,
                ConfigPath:       configPath,
                APIConfig:        apiConfig,
                Version:          version,
                Logger:           logger,
                DisableTaskStart: disableTaskStart,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">errCh := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                errCh &lt;- server.ListenAndServe()
        }</span>()

        <span class="cov8" title="1">signalCh := make(chan os.Signal, 1)
        signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)

        select </span>{
        case err := &lt;-errCh:<span class="cov8" title="1">
                if err == nil || errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return err</span>
        case &lt;-signalCh:<span class="cov0" title="0">
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("shutdown server: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func parseBool(value string) bool <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(value)) </span>{
        case "1", "true", "yes", "y", "on":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/runner"
        "github.com/spf13/cobra"
)

const version = "dev"

func main() <span class="cov0" title="0">{
        if err := newRootCmd().Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func newRootCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:          "run-agent",
                Short:        "Conductor Loop run-agent CLI",
                Version:      version,
                SilenceUsage: true,
        }
        cmd.SetVersionTemplate("{{.Version}}\n")

        cmd.AddCommand(newTaskCmd())
        cmd.AddCommand(newJobCmd())

        return cmd
}</span>

func newTaskCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                projectID string
                taskID    string
                opts      runner.TaskOptions
        )

        cmd := &amp;cobra.Command{
                Use:   "task",
                Short: "Run a task with the Ralph loop",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        projectID = strings.TrimSpace(projectID)
                        taskID = strings.TrimSpace(taskID)
                        if projectID == "" || taskID == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("project and task are required")
                        }</span>
                        <span class="cov0" title="0">return runner.RunTask(projectID, taskID, opts)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVar(&amp;projectID, "project", "", "project id")
        cmd.Flags().StringVar(&amp;taskID, "task", "", "task id")
        cmd.Flags().StringVar(&amp;opts.RootDir, "root", "", "run-agent root directory")
        cmd.Flags().StringVar(&amp;opts.ConfigPath, "config", "", "config file path")
        cmd.Flags().StringVar(&amp;opts.Agent, "agent", "", "agent type")
        cmd.Flags().StringVar(&amp;opts.Prompt, "prompt", "", "prompt override")
        cmd.Flags().StringVar(&amp;opts.WorkingDir, "cwd", "", "working directory")
        cmd.Flags().StringVar(&amp;opts.MessageBusPath, "message-bus", "", "message bus path")
        cmd.Flags().IntVar(&amp;opts.MaxRestarts, "max-restarts", 0, "max restarts")
        cmd.Flags().DurationVar(&amp;opts.WaitTimeout, "child-wait-timeout", 0, "child wait timeout")
        cmd.Flags().DurationVar(&amp;opts.PollInterval, "child-poll-interval", 0, "child poll interval")
        cmd.Flags().DurationVar(&amp;opts.RestartDelay, "restart-delay", time.Second, "restart delay")

        return cmd</span>
}

func newJobCmd() *cobra.Command <span class="cov8" title="1">{
        var (
                projectID string
                taskID    string
                opts      runner.JobOptions
        )

        cmd := &amp;cobra.Command{
                Use:   "job",
                Short: "Run a single agent job",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        projectID = strings.TrimSpace(projectID)
                        taskID = strings.TrimSpace(taskID)
                        if projectID == "" || taskID == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("project and task are required")
                        }</span>
                        <span class="cov0" title="0">return runner.RunJob(projectID, taskID, opts)</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVar(&amp;projectID, "project", "", "project id")
        cmd.Flags().StringVar(&amp;taskID, "task", "", "task id")
        cmd.Flags().StringVar(&amp;opts.RootDir, "root", "", "run-agent root directory")
        cmd.Flags().StringVar(&amp;opts.ConfigPath, "config", "", "config file path")
        cmd.Flags().StringVar(&amp;opts.Agent, "agent", "", "agent type")
        cmd.Flags().StringVar(&amp;opts.Prompt, "prompt", "", "prompt text")
        cmd.Flags().StringVar(&amp;opts.PromptPath, "prompt-file", "", "prompt file path")
        cmd.Flags().StringVar(&amp;opts.WorkingDir, "cwd", "", "working directory")
        cmd.Flags().StringVar(&amp;opts.MessageBusPath, "message-bus", "", "message bus path")
        cmd.Flags().StringVar(&amp;opts.ParentRunID, "parent-run-id", "", "parent run id")
        cmd.Flags().StringVar(&amp;opts.PreviousRunID, "previous-run-id", "", "previous run id")

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package claude implements the Claude agent backend.
package claude

import (
        "context"
        "io"
        "os"
        "os/exec"
        "sort"
        "strings"

        "github.com/pkg/errors"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
)

const claudeCommand = "claude"

// ClaudeAgent implements the Claude CLI backend.
type ClaudeAgent struct {
        token string
        model string
}

// Execute runs the Claude CLI for the provided run context.
func (a *ClaudeAgent) Execute(ctx context.Context, runCtx *agent.RunContext) (err error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">if runCtx == nil </span><span class="cov8" title="1">{
                return errors.New("run context is nil")
        }</span>
        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return errors.Wrap(ctx.Err(), "context canceled")
        }</span>

        <span class="cov8" title="1">workingDir := strings.TrimSpace(runCtx.WorkingDir)
        if workingDir == "" </span><span class="cov8" title="1">{
                return errors.New("working dir is empty")
        }</span>

        <span class="cov8" title="1">promptReader, closePrompt, err := openPrompt(runCtx.Prompt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := closePrompt(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(closeErr, "close prompt")
                }</span>
        }()

        <span class="cov8" title="1">capture, err := agent.CaptureOutput(nil, nil, agent.OutputFiles{
                StdoutPath: runCtx.StdoutPath,
                StderrPath: runCtx.StderrPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "capture output")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := capture.Close(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(closeErr, "close output capture")
                }</span>
        }()

        <span class="cov8" title="1">args := claudeArgs(workingDir)
        env := buildEnvironment(runCtx.Environment, a.token)

        cmd, err := agent.SpawnProcessWithOptions(claudeCommand, args, promptReader, capture.Stdout, capture.Stderr, agent.ProcessOptions{
                Dir: workingDir,
                Env: env,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "spawn claude")
        }</span>

        <span class="cov8" title="1">if err := waitForProcess(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Type returns the backend type identifier.
func (a *ClaudeAgent) Type() string <span class="cov0" title="0">{
        return "claude"
}</span>

func openPrompt(prompt string) (io.Reader, func() error, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(prompt)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, nil, errors.New("prompt is empty")
        }</span>

        <span class="cov8" title="1">info, err := os.Stat(trimmed)
        if err == nil </span><span class="cov8" title="1">{
                if info.IsDir() </span><span class="cov8" title="1">{
                        return nil, nil, errors.New("prompt path is a directory")
                }</span>
                <span class="cov8" title="1">file, err := os.Open(trimmed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errors.Wrap(err, "open prompt file")
                }</span>
                <span class="cov8" title="1">return file, file.Close, nil</span>
        }
        <span class="cov8" title="1">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "stat prompt")
        }</span>

        <span class="cov8" title="1">return strings.NewReader(prompt), func() error </span><span class="cov8" title="1">{ return nil }</span>, nil
}

func claudeArgs(workingDir string) []string <span class="cov8" title="1">{
        args := []string{
                "-p",
                "--input-format",
                "text",
                "--output-format",
                "text",
                "--tools",
                "default",
                "--permission-mode",
                "bypassPermissions",
        }
        if strings.TrimSpace(workingDir) == "" </span><span class="cov8" title="1">{
                return args
        }</span>
        <span class="cov8" title="1">return append([]string{"-C", workingDir}, args...)</span>
}

func buildEnvironment(overrides map[string]string, token string) []string <span class="cov8" title="1">{
        merged := make(map[string]string)
        for key, value := range overrides </span><span class="cov8" title="1">{
                cleanKey := strings.TrimSpace(key)
                if cleanKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">merged[cleanKey] = value</span>
        }

        <span class="cov8" title="1">trimmedToken := strings.TrimSpace(token)
        if trimmedToken != "" </span><span class="cov8" title="1">{
                if _, exists := merged["ANTHROPIC_API_KEY"]; !exists </span><span class="cov8" title="1">{
                        merged["ANTHROPIC_API_KEY"] = trimmedToken
                }</span>
        }

        <span class="cov8" title="1">return mergeEnvironment(os.Environ(), merged)</span>
}

func mergeEnvironment(base []string, overrides map[string]string) []string <span class="cov8" title="1">{
        merged := make(map[string]string, len(base)+len(overrides))
        for _, entry := range base </span><span class="cov8" title="1">{
                if entry == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts := strings.SplitN(entry, "=", 2)
                key := strings.TrimSpace(parts[0])
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value := ""
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        value = parts[1]
                }</span>
                <span class="cov8" title="1">merged[key] = value</span>
        }
        <span class="cov8" title="1">for key, value := range overrides </span><span class="cov8" title="1">{
                cleanKey := strings.TrimSpace(key)
                if cleanKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">merged[cleanKey] = value</span>
        }

        <span class="cov8" title="1">keys := make([]string, 0, len(merged))
        for key := range merged </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        result := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                result = append(result, key+"="+merged[key])
        }</span>
        <span class="cov8" title="1">return result</span>
}

func waitForProcess(ctx context.Context, cmd *exec.Cmd) error <span class="cov8" title="1">{
        if cmd == nil </span><span class="cov0" title="0">{
                return errors.New("command is nil")
        }</span>
        <span class="cov8" title="1">waitCh := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                waitCh &lt;- cmd.Wait()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                if cmd.Process != nil </span><span class="cov8" title="1">{
                        _ = cmd.Process.Kill()
                }</span>
                <span class="cov8" title="1">waitErr := &lt;-waitCh
                if waitErr != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(ctx.Err(), "claude execution canceled")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(ctx.Err(), "claude execution canceled")</span>
        case waitErr := &lt;-waitCh:<span class="cov8" title="1">
                if waitErr != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(waitErr, "claude execution failed")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package codex implements the Codex CLI agent backend.
package codex

import (
        "context"
        "io"
        "os"
        "os/exec"
        "sort"
        "strings"

        "github.com/pkg/errors"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
)

const (
        codexCommand = "codex"
        tokenEnvVar  = "OPENAI_API_KEY"
)

// CodexAgent implements the Codex CLI backend.
type CodexAgent struct {
        token string
}

// Execute runs the Codex CLI for the provided run context.
func (a *CodexAgent) Execute(ctx context.Context, runCtx *agent.RunContext) (err error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">if runCtx == nil </span><span class="cov8" title="1">{
                return errors.New("run context is nil")
        }</span>
        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov8" title="1">{
                return errors.Wrap(ctx.Err(), "context canceled")
        }</span>

        <span class="cov8" title="1">workingDir := strings.TrimSpace(runCtx.WorkingDir)
        if workingDir == "" </span><span class="cov8" title="1">{
                return errors.New("working dir is empty")
        }</span>

        <span class="cov8" title="1">promptReader, closePrompt, err := openPrompt(runCtx.Prompt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := closePrompt(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(closeErr, "close prompt")
                }</span>
        }()

        <span class="cov8" title="1">capture, err := agent.CaptureOutput(nil, nil, agent.OutputFiles{
                StdoutPath: runCtx.StdoutPath,
                StderrPath: runCtx.StderrPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "capture output")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := capture.Close(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(closeErr, "close output capture")
                }</span>
        }()

        <span class="cov8" title="1">args := codexArgs(workingDir)
        env := buildEnvironment(runCtx.Environment, a.token)

        cmd, err := agent.SpawnProcessWithOptions(codexCommand, args, promptReader, capture.Stdout, capture.Stderr, agent.ProcessOptions{
                Dir: workingDir,
                Env: env,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "spawn codex")
        }</span>

        <span class="cov8" title="1">if err := waitForProcess(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Type returns the backend type identifier.
func (a *CodexAgent) Type() string <span class="cov8" title="1">{
        return "codex"
}</span>

func openPrompt(prompt string) (io.Reader, func() error, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(prompt)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, nil, errors.New("prompt is empty")
        }</span>

        <span class="cov8" title="1">info, err := os.Stat(trimmed)
        if err == nil </span><span class="cov8" title="1">{
                if info.IsDir() </span><span class="cov8" title="1">{
                        return nil, nil, errors.New("prompt path is a directory")
                }</span>
                <span class="cov8" title="1">file, err := os.Open(trimmed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errors.Wrap(err, "open prompt file")
                }</span>
                <span class="cov8" title="1">return file, file.Close, nil</span>
        }
        <span class="cov8" title="1">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "stat prompt")
        }</span>

        <span class="cov8" title="1">return strings.NewReader(prompt), func() error </span><span class="cov8" title="1">{ return nil }</span>, nil
}

func codexArgs(workingDir string) []string <span class="cov8" title="1">{
        args := []string{
                "exec",
                "--dangerously-bypass-approvals-and-sandbox",
                "-",
        }
        if strings.TrimSpace(workingDir) == "" </span><span class="cov8" title="1">{
                return args
        }</span>
        <span class="cov8" title="1">return []string{
                "exec",
                "--dangerously-bypass-approvals-and-sandbox",
                "-C",
                workingDir,
                "-",
        }</span>
}

func buildEnvironment(overrides map[string]string, token string) []string <span class="cov8" title="1">{
        merged := make(map[string]string)
        for key, value := range overrides </span><span class="cov8" title="1">{
                cleanKey := strings.TrimSpace(key)
                if cleanKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">merged[cleanKey] = value</span>
        }

        <span class="cov8" title="1">trimmedToken := strings.TrimSpace(token)
        if trimmedToken != "" </span><span class="cov8" title="1">{
                if _, exists := merged[tokenEnvVar]; !exists </span><span class="cov8" title="1">{
                        merged[tokenEnvVar] = trimmedToken
                }</span>
        }

        <span class="cov8" title="1">return mergeEnvironment(os.Environ(), merged)</span>
}

func mergeEnvironment(base []string, overrides map[string]string) []string <span class="cov8" title="1">{
        merged := make(map[string]string, len(base)+len(overrides))
        for _, entry := range base </span><span class="cov8" title="1">{
                if entry == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts := strings.SplitN(entry, "=", 2)
                key := strings.TrimSpace(parts[0])
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value := ""
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        value = parts[1]
                }</span>
                <span class="cov8" title="1">merged[key] = value</span>
        }
        <span class="cov8" title="1">for key, value := range overrides </span><span class="cov8" title="1">{
                cleanKey := strings.TrimSpace(key)
                if cleanKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">merged[cleanKey] = value</span>
        }

        <span class="cov8" title="1">keys := make([]string, 0, len(merged))
        for key := range merged </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        result := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                result = append(result, key+"="+merged[key])
        }</span>
        <span class="cov8" title="1">return result</span>
}

func waitForProcess(ctx context.Context, cmd *exec.Cmd) error <span class="cov8" title="1">{
        if cmd == nil </span><span class="cov0" title="0">{
                return errors.New("command is nil")
        }</span>
        <span class="cov8" title="1">waitCh := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                waitCh &lt;- cmd.Wait()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                if cmd.Process != nil </span><span class="cov8" title="1">{
                        _ = cmd.Process.Kill()
                }</span>
                <span class="cov8" title="1">waitErr := &lt;-waitCh
                if waitErr != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(ctx.Err(), "codex execution canceled")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(ctx.Err(), "codex execution canceled")</span>
        case waitErr := &lt;-waitCh:<span class="cov8" title="1">
                if waitErr != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(waitErr, "codex execution failed")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

var _ agent.Agent = (*CodexAgent)(nil)
</pre>
		
		<pre class="file" id="file4" style="display: none">package agent

import (
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
)

// ProcessOptions controls process spawn behavior.
type ProcessOptions struct {
        Dir string
        Env []string
}

// SpawnProcess starts a detached process with stdio attached.
func SpawnProcess(command string, args []string, stdin io.Reader, stdout, stderr io.Writer) (*exec.Cmd, error) <span class="cov8" title="1">{
        return SpawnProcessWithOptions(command, args, stdin, stdout, stderr, ProcessOptions{})
}</span>

// SpawnProcessWithOptions starts a detached process with stdio attached and optional settings.
func SpawnProcessWithOptions(command string, args []string, stdin io.Reader, stdout, stderr io.Writer, opts ProcessOptions) (*exec.Cmd, error) <span class="cov8" title="1">{
        clean := strings.TrimSpace(command)
        if clean == "" </span><span class="cov8" title="1">{
                return nil, errors.New("command is empty")
        }</span>
        <span class="cov8" title="1">cmd := exec.Command(clean, args...)
        cmd.Stdin = stdin
        cmd.Stdout = stdout
        cmd.Stderr = stderr
        if dir := strings.TrimSpace(opts.Dir); dir != "" </span><span class="cov8" title="1">{
                cmd.Dir = dir
        }</span>
        <span class="cov8" title="1">if len(opts.Env) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Env = opts.Env
        }</span>
        <span class="cov8" title="1">applyProcessGroup(cmd)
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "start process")
        }</span>
        <span class="cov8" title="1">return cmd, nil</span>
}

// CreateOutputMD ensures output.md exists, copying from fallback when needed.
func CreateOutputMD(runDir, fallback string) (string, error) <span class="cov8" title="1">{
        cleanRunDir := filepath.Clean(strings.TrimSpace(runDir))
        if cleanRunDir == "." || cleanRunDir == "" </span><span class="cov8" title="1">{
                return "", errors.New("run directory is empty")
        }</span>
        <span class="cov8" title="1">if info, err := os.Stat(cleanRunDir); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "stat run directory")
        }</span> else<span class="cov8" title="1"> if !info.IsDir() </span><span class="cov8" title="1">{
                return "", errors.New("run directory is not a directory")
        }</span>

        <span class="cov8" title="1">outputPath := filepath.Join(cleanRunDir, "output.md")
        if info, err := os.Stat(outputPath); err == nil </span><span class="cov8" title="1">{
                if info.IsDir() </span><span class="cov8" title="1">{
                        return "", errors.New("output.md is a directory")
                }</span>
                <span class="cov8" title="1">return outputPath, nil</span>
        } else<span class="cov8" title="1"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "stat output.md")
        }</span>

        <span class="cov8" title="1">fallbackPath := strings.TrimSpace(fallback)
        if fallbackPath == "" </span><span class="cov8" title="1">{
                fallbackPath = filepath.Join(cleanRunDir, "agent-stdout.txt")
        }</span> else<span class="cov8" title="1"> if !filepath.IsAbs(fallbackPath) </span><span class="cov8" title="1">{
                fallbackPath = filepath.Join(cleanRunDir, fallbackPath)
        }</span>

        <span class="cov8" title="1">input, err := os.Open(fallbackPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, "open fallback output")
        }</span>

        <span class="cov8" title="1">outputFile, err := os.OpenFile(outputPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
        if err != nil </span><span class="cov8" title="1">{
                _ = input.Close()
                return "", errors.Wrap(err, "create output.md")
        }</span>
        <span class="cov8" title="1">if _, err := io.Copy(outputFile, input); err != nil </span><span class="cov0" title="0">{
                _ = outputFile.Close()
                _ = input.Close()
                return "", errors.Wrap(err, "copy output.md")
        }</span>
        <span class="cov8" title="1">if err := outputFile.Sync(); err != nil </span><span class="cov0" title="0">{
                _ = outputFile.Close()
                _ = input.Close()
                return "", errors.Wrap(err, "sync output.md")
        }</span>
        <span class="cov8" title="1">if err := outputFile.Close(); err != nil </span><span class="cov0" title="0">{
                _ = input.Close()
                return "", errors.Wrap(err, "close output.md")
        }</span>
        <span class="cov8" title="1">if err := input.Close(); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "close fallback output")
        }</span>
        <span class="cov8" title="1">return outputPath, nil</span>
}

var _ = CreateOutputMD
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package gemini implements the Gemini agent backend using the REST API.
package gemini

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "path"
        "strings"

        "github.com/pkg/errors"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
)

const (
        defaultBaseURL = "https://generativelanguage.googleapis.com"
        defaultModel   = "gemini-1.5-pro"
        tokenEnvVar    = "GEMINI_API_KEY"
)

// GeminiAgent invokes the Gemini REST API with streaming responses.
type GeminiAgent struct {
        Token      string
        BaseURL    string
        Model      string
        HTTPClient *http.Client
}

// Type returns the agent type identifier.
func (a *GeminiAgent) Type() string <span class="cov0" title="0">{
        return "gemini"
}</span>

// Execute sends the prompt to Gemini and streams the response to stdout.
func (a *GeminiAgent) Execute(ctx context.Context, runCtx *agent.RunContext) (retErr error) <span class="cov8" title="1">{
        if runCtx == nil </span><span class="cov0" title="0">{
                return errors.New("run context is nil")
        }</span>
        <span class="cov8" title="1">token := strings.TrimSpace(a.Token)
        if token == "" </span><span class="cov8" title="1">{
                token = strings.TrimSpace(runCtx.Environment[tokenEnvVar])
        }</span>
        <span class="cov8" title="1">if token == "" </span><span class="cov8" title="1">{
                token = strings.TrimSpace(os.Getenv(tokenEnvVar))
        }</span>
        <span class="cov8" title="1">if token == "" </span><span class="cov0" title="0">{
                return errors.New("gemini token is empty")
        }</span>

        <span class="cov8" title="1">baseURL := strings.TrimSpace(a.BaseURL)
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = defaultBaseURL
        }</span>

        <span class="cov8" title="1">model := strings.TrimSpace(a.Model)
        if model == "" </span><span class="cov8" title="1">{
                model = defaultModel
        }</span>

        <span class="cov8" title="1">capture, err := agent.CaptureOutput(nil, nil, agent.OutputFiles{
                StdoutPath: runCtx.StdoutPath,
                StderrPath: runCtx.StderrPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "capture output")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := capture.Close(); err != nil &amp;&amp; retErr == nil </span><span class="cov0" title="0">{
                        retErr = errors.Wrap(err, "close output")
                }</span>
        }()

        <span class="cov8" title="1">stdout := bufio.NewWriter(capture.Stdout)
        stderr := bufio.NewWriter(capture.Stderr)
        defer func() </span><span class="cov8" title="1">{
                _ = stdout.Flush()
                _ = stderr.Flush()
        }</span>()

        <span class="cov8" title="1">if err := a.stream(ctx, token, baseURL, model, runCtx.Prompt, stdout, stderr); err != nil </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(stderr, "gemini request failed: %v\n", err)
                _ = stderr.Flush()
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *GeminiAgent) stream(ctx context.Context, token, baseURL, model, prompt string, stdout, stderr io.Writer) error <span class="cov8" title="1">{
        endpoint, err := buildEndpoint(baseURL, model)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">payload, err := json.Marshal(geminiRequest{
                Contents: []geminiContent{{
                        Role:  "user",
                        Parts: []geminiPart{{Text: prompt}},
                }},
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "marshal request")
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "build request")
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("x-goog-api-key", token)

        client := a.HTTPClient
        if client == nil </span><span class="cov8" title="1">{
                client = &amp;http.Client{
                        Timeout: 0,
                }
        }</span>

        <span class="cov8" title="1">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "call gemini api")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(io.LimitReader(resp.Body, 4*1024))
                return errors.Errorf("gemini api request failed: status %s: %s", resp.Status, strings.TrimSpace(string(body)))
        }</span>

        <span class="cov8" title="1">return readStream(resp.Body, stdout, stderr)</span>
}

func buildEndpoint(baseURL, model string) (string, error) <span class="cov8" title="1">{
        parsed, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "parse base url")
        }</span>
        <span class="cov8" title="1">if parsed.Scheme == "" </span><span class="cov0" title="0">{
                return "", errors.New("base url scheme is empty")
        }</span>
        <span class="cov8" title="1">if parsed.Host == "" </span><span class="cov8" title="1">{
                return "", errors.New("base url host is empty")
        }</span>

        <span class="cov8" title="1">parsed.Path = path.Join(parsed.Path, "v1beta", "models", model+":streamGenerateContent")
        query := parsed.Query()
        query.Set("alt", "sse")
        parsed.RawQuery = query.Encode()
        return parsed.String(), nil</span>
}

func readStream(reader io.Reader, stdout, stderr io.Writer) error <span class="cov8" title="1">{
        scanner := bufio.NewScanner(reader)
        buf := make([]byte, 0, 64*1024)
        scanner.Buffer(buf, 1024*1024)

        var emitted string
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, ":") || strings.HasPrefix(line, "event:") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(line, "data:") </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(strings.TrimPrefix(line, "data:"))
                }</span>
                <span class="cov8" title="1">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if line == "[DONE]" </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">text, err := extractText(line)
                if err != nil </span><span class="cov8" title="1">{
                        if stderr != nil </span><span class="cov8" title="1">{
                                _, _ = fmt.Fprintf(stderr, "gemini stream parse error: %v\n", err)
                                flushIfPossible(stderr)
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }

                <span class="cov8" title="1">if text == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">delta := diffText(emitted, text)
                if delta == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if _, err := io.WriteString(stdout, delta); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write stdout")
                }</span>
                <span class="cov8" title="1">flushIfPossible(stdout)
                emitted += delta</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "read stream")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func flushIfPossible(writer io.Writer) <span class="cov8" title="1">{
        if flusher, ok := writer.(interface{ Flush() error }); ok </span><span class="cov0" title="0">{
                _ = flusher.Flush()
                return
        }</span>
        <span class="cov8" title="1">if flusher, ok := writer.(interface{ Flush() }); ok </span><span class="cov0" title="0">{
                flusher.Flush()
        }</span>
}

func diffText(emitted, next string) string <span class="cov8" title="1">{
        if strings.HasPrefix(next, emitted) </span><span class="cov8" title="1">{
                return next[len(emitted):]
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(emitted, next) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return next</span>
}

type geminiRequest struct {
        Contents []geminiContent `json:"contents"`
}

type geminiContent struct {
        Role  string       `json:"role,omitempty"`
        Parts []geminiPart `json:"parts"`
}

type geminiPart struct {
        Text string `json:"text,omitempty"`
}

type geminiResponse struct {
        Candidates []geminiCandidate `json:"candidates"`
        Error      *geminiError      `json:"error,omitempty"`
}

type geminiCandidate struct {
        Content geminiContent `json:"content"`
}

type geminiError struct {
        Message string `json:"message"`
}

func extractText(payload string) (string, error) <span class="cov8" title="1">{
        var resp geminiResponse
        if err := json.Unmarshal([]byte(payload), &amp;resp); err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, "decode gemini response")
        }</span>
        <span class="cov8" title="1">if resp.Error != nil &amp;&amp; resp.Error.Message != "" </span><span class="cov8" title="1">{
                return "", errors.Errorf("gemini api error: %s", strings.TrimSpace(resp.Error.Message))
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        for _, candidate := range resp.Candidates </span><span class="cov8" title="1">{
                for _, part := range candidate.Content.Parts </span><span class="cov8" title="1">{
                        if part.Text != "" </span><span class="cov8" title="1">{
                                builder.WriteString(part.Text)
                        }</span>
                }
        }
        <span class="cov8" title="1">return builder.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package perplexity provides a Perplexity REST/SSE agent backend.
package perplexity

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/pkg/errors"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
)

const (
        defaultPerplexityEndpoint = "https://api.perplexity.ai/chat/completions"
        defaultPerplexityModel    = "sonar-reasoning"
        perplexityTokenEnv        = "PERPLEXITY_API_KEY"
        maxRetryAttempts          = 5
)

const (
        connectTimeout        = 10 * time.Second
        tlsHandshakeTimeout   = 10 * time.Second
        responseHeaderTimeout = 10 * time.Second
        idleStreamTimeout     = 60 * time.Second
        totalRequestTimeout   = 2 * time.Minute
        maxScannerTokenSize   = 1024 * 1024
)

// Options defines configuration for a Perplexity agent backend.
type Options struct {
        Token       string
        Model       string
        APIEndpoint string
        HTTPClient  *http.Client
}

// PerplexityAgent implements the agent.Agent interface for Perplexity.
type PerplexityAgent struct {
        token       string
        model       string
        apiEndpoint string
        client      *http.Client
        idleTimeout time.Duration
}

// NewPerplexityAgent constructs a PerplexityAgent with the provided options.
func NewPerplexityAgent(options Options) *PerplexityAgent <span class="cov8" title="1">{
        endpoint := strings.TrimSpace(options.APIEndpoint)
        if endpoint == "" </span><span class="cov8" title="1">{
                endpoint = defaultPerplexityEndpoint
        }</span>
        <span class="cov8" title="1">model := strings.TrimSpace(options.Model)
        if model == "" </span><span class="cov8" title="1">{
                model = defaultPerplexityModel
        }</span>
        <span class="cov8" title="1">return &amp;PerplexityAgent{
                token:       strings.TrimSpace(options.Token),
                model:       model,
                apiEndpoint: endpoint,
                client:      options.HTTPClient,
                idleTimeout: idleStreamTimeout,
        }</span>
}

// Execute runs the Perplexity API request and streams tokens to stdout.
func (a *PerplexityAgent) Execute(ctx context.Context, runCtx *agent.RunContext) (err error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">if runCtx == nil </span><span class="cov0" title="0">{
                return errors.New("run context is nil")
        }</span>

        <span class="cov8" title="1">capture, err := agent.CaptureOutput(nil, nil, agent.OutputFiles{
                StdoutPath: runCtx.StdoutPath,
                StderrPath: runCtx.StderrPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "capture output")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if cerr := capture.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(cerr, "close output capture")
                }</span>
        }()

        <span class="cov8" title="1">token := resolveToken(a.token, runCtx.Environment)
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("perplexity api token is empty")
        }</span>

        <span class="cov8" title="1">model := strings.TrimSpace(a.model)
        if model == "" </span><span class="cov0" title="0">{
                model = defaultPerplexityModel
        }</span>
        <span class="cov8" title="1">endpoint := strings.TrimSpace(a.apiEndpoint)
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = defaultPerplexityEndpoint
        }</span>

        <span class="cov8" title="1">payload, err := json.Marshal(perplexityRequest{
                Model: model,
                Messages: []perplexityMessage{{
                        Role:    "user",
                        Content: runCtx.Prompt,
                }},
                Stream: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "marshal request")
        }</span>

        <span class="cov8" title="1">client := a.client
        if client == nil </span><span class="cov0" title="0">{
                client = defaultHTTPClient()
        }</span>
        <span class="cov8" title="1">return executeWithRetry(ctx, client, endpoint, token, payload, capture.Stdout, capture.Stderr, a.idleTimeout)</span>
}

// Type returns the agent type.
func (a *PerplexityAgent) Type() string <span class="cov8" title="1">{
        return "perplexity"
}</span>

type perplexityRequest struct {
        Model    string              `json:"model"`
        Messages []perplexityMessage `json:"messages"`
        Stream   bool                `json:"stream"`
}

type perplexityMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type perplexityStreamResponse struct {
        Choices       []perplexityChoice       `json:"choices"`
        Citations     []string                 `json:"citations"`
        SearchResults []perplexitySearchResult `json:"search_results"`
        Error         *perplexityError         `json:"error"`
}

type perplexityChoice struct {
        Delta        perplexityDelta   `json:"delta"`
        Message      perplexityMessage `json:"message"`
        FinishReason string            `json:"finish_reason"`
        Index        int               `json:"index"`
        Logprobs     *json.RawMessage  `json:"logprobs"`
}

type perplexityDelta struct {
        Content string `json:"content"`
}

type perplexitySearchResult struct {
        Title string `json:"title"`
        URL   string `json:"url"`
}

type perplexityError struct {
        Message string `json:"message"`
        Type    string `json:"type"`
}

type streamState struct {
        lastContent  string
        citations    []string
        searchResult []perplexitySearchResult
}

func resolveToken(fallback string, env map[string]string) string <span class="cov8" title="1">{
        if env != nil </span><span class="cov8" title="1">{
                if value := strings.TrimSpace(env[perplexityTokenEnv]); value != "" </span><span class="cov8" title="1">{
                        return value
                }</span>
        }
        <span class="cov8" title="1">if strings.TrimSpace(fallback) != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(fallback)
        }</span>
        <span class="cov8" title="1">if value, ok := os.LookupEnv(perplexityTokenEnv); ok </span><span class="cov8" title="1">{
                return strings.TrimSpace(value)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func defaultHTTPClient() *http.Client <span class="cov8" title="1">{
        transport := &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   connectTimeout,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                TLSHandshakeTimeout:   tlsHandshakeTimeout,
                ResponseHeaderTimeout: responseHeaderTimeout,
                IdleConnTimeout:       90 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }
        return &amp;http.Client{
                Transport: transport,
                Timeout:   totalRequestTimeout,
        }
}</span>

func executeWithRetry(ctx context.Context, client *http.Client, endpoint, token string, payload []byte, stdout, stderr io.Writer, idleTimeout time.Duration) error <span class="cov8" title="1">{
        if client == nil </span><span class="cov8" title="1">{
                return errors.New("http client is nil")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(endpoint) == "" </span><span class="cov8" title="1">{
                return errors.New("perplexity api endpoint is empty")
        }</span>
        <span class="cov8" title="1">rng := rand.New(rand.NewSource(time.Now().UnixNano()))

        for attempt := 0; attempt &lt; maxRetryAttempts; attempt++ </span><span class="cov8" title="1">{
                reqCtx, cancel := context.WithCancel(ctx)
                req, err := http.NewRequestWithContext(reqCtx, http.MethodPost, endpoint, bytes.NewReader(payload))
                if err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return errors.Wrap(err, "create request")
                }</span>
                <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token)
                req.Header.Set("Content-Type", "application/json")
                req.Header.Set("Accept", "text/event-stream")

                resp, err := client.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        cancel()
                        if ctx.Err() != nil </span><span class="cov8" title="1">{
                                return errors.Wrap(ctx.Err(), "request canceled")
                        }</span>
                        <span class="cov0" title="0">if attempt &lt; maxRetryAttempts-1 </span><span class="cov0" title="0">{
                                delay := retryDelay(nil, attempt, rng)
                                logRetry(stderr, delay, 0, err)
                                if err := sleepWithContext(ctx, delay); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">return errors.Wrap(err, "send request")</span>
                }

                <span class="cov8" title="1">if resp.StatusCode == http.StatusOK </span><span class="cov8" title="1">{
                        state := &amp;streamState{}
                        err = consumeStream(reqCtx, cancel, resp.Body, stdout, idleTimeout, state)
                        cancel()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return appendCitations(stdout, state.citations, state.searchResult)</span>
                }

                <span class="cov8" title="1">status := resp.StatusCode
                bodyText := readErrorBody(resp.Body)
                _ = resp.Body.Close()
                cancel()

                retryable := status == http.StatusTooManyRequests || status &gt;= http.StatusInternalServerError
                if retryable &amp;&amp; attempt &lt; maxRetryAttempts-1 </span><span class="cov8" title="1">{
                        delay := retryDelay(resp, attempt, rng)
                        logRetry(stderr, delay, status, nil)
                        if err := sleepWithContext(ctx, delay); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if bodyText != "" </span><span class="cov8" title="1">{
                        return errors.Errorf("perplexity api error: status %d: %s", status, bodyText)
                }</span>
                <span class="cov0" title="0">return errors.Errorf("perplexity api error: status %d", status)</span>
        }
        <span class="cov0" title="0">return errors.New("perplexity request failed after retries")</span>
}

func consumeStream(ctx context.Context, cancel context.CancelFunc, body io.ReadCloser, stdout io.Writer, idleTimeout time.Duration, state *streamState) error <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                return errors.New("response body is nil")
        }</span>
        <span class="cov8" title="1">defer body.Close()

        activity, idleTriggered := startIdleMonitor(ctx, cancel, idleTimeout)

        scanner := bufio.NewScanner(body)
        scanner.Buffer(make([]byte, 0, 64*1024), maxScannerTokenSize)

        dataLines := make([]string, 0, 4)
        for scanner.Scan() </span><span class="cov8" title="1">{
                signalActivity(activity)
                line := scanner.Text()
                if line == "" </span><span class="cov8" title="1">{
                        if len(dataLines) &gt; 0 </span><span class="cov8" title="1">{
                                done, err := handleEvent(strings.Join(dataLines, "\n"), stdout, state)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if done </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">dataLines = dataLines[:0]</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, "data:") </span><span class="cov8" title="1">{
                        dataLines = append(dataLines, strings.TrimSpace(line[len("data:"):]))
                }</span>
        }
        <span class="cov8" title="1">if len(dataLines) &gt; 0 </span><span class="cov0" title="0">{
                done, err := handleEvent(strings.Join(dataLines, "\n"), stdout, state)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov8" title="1">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return streamContextError(ctx, idleTriggered)
                }</span>
                <span class="cov8" title="1">return errors.Wrap(err, "read stream")</span>
        }
        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return streamContextError(ctx, idleTriggered)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func handleEvent(payload string, stdout io.Writer, state *streamState) (bool, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(payload)
        if trimmed == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if trimmed == "[DONE]" </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">var chunk perplexityStreamResponse
        if err := json.Unmarshal([]byte(trimmed), &amp;chunk); err != nil </span><span class="cov8" title="1">{
                return false, errors.Wrap(err, "parse stream chunk")
        }</span>
        <span class="cov8" title="1">if chunk.Error != nil </span><span class="cov8" title="1">{
                message := strings.TrimSpace(chunk.Error.Message)
                if message == "" </span><span class="cov8" title="1">{
                        message = "perplexity stream error"
                }</span>
                <span class="cov8" title="1">return false, errors.New(message)</span>
        }

        <span class="cov8" title="1">if len(chunk.Choices) &gt; 0 </span><span class="cov8" title="1">{
                choice := chunk.Choices[0]
                if choice.FinishReason == "error" </span><span class="cov8" title="1">{
                        return false, errors.New("perplexity stream finished with error")
                }</span>
                <span class="cov8" title="1">content := extractContent(choice)
                if err := appendContent(stdout, content, &amp;state.lastContent); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">if len(chunk.Citations) &gt; 0 </span><span class="cov8" title="1">{
                state.citations = append(state.citations, chunk.Citations...)
        }</span>
        <span class="cov8" title="1">if len(chunk.SearchResults) &gt; 0 </span><span class="cov0" title="0">{
                state.searchResult = append(state.searchResult, chunk.SearchResults...)
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

func extractContent(choice perplexityChoice) string <span class="cov8" title="1">{
        if choice.Delta.Content != "" </span><span class="cov8" title="1">{
                return choice.Delta.Content
        }</span>
        <span class="cov8" title="1">if choice.Message.Content != "" </span><span class="cov8" title="1">{
                return choice.Message.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func appendContent(stdout io.Writer, content string, last *string) error <span class="cov8" title="1">{
        if stdout == nil </span><span class="cov8" title="1">{
                return errors.New("stdout writer is nil")
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if last != nil &amp;&amp; *last != "" &amp;&amp; strings.HasPrefix(content, *last) </span><span class="cov8" title="1">{
                content = strings.TrimPrefix(content, *last)
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(stdout, content); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write stdout")
        }</span>
        <span class="cov8" title="1">if last != nil </span><span class="cov8" title="1">{
                *last += content
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func appendCitations(stdout io.Writer, citations []string, searchResults []perplexitySearchResult) error <span class="cov8" title="1">{
        items := make([]string, 0, len(citations)+len(searchResults))
        seen := make(map[string]struct{})
        for _, cite := range citations </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(cite)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[trimmed]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[trimmed] = struct{}{}
                items = append(items, trimmed)</span>
        }
        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                for _, result := range searchResults </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(result.URL)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, exists := seen[trimmed]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[trimmed] = struct{}{}
                        items = append(items, trimmed)</span>
                }
        }
        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(stdout, "\n\nSources:\n"); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write citations header")
        }</span>
        <span class="cov8" title="1">for i, item := range items </span><span class="cov8" title="1">{
                line := fmt.Sprintf("[%d] %s\n", i+1, item)
                if _, err := io.WriteString(stdout, line); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write citations")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func startIdleMonitor(ctx context.Context, cancel context.CancelFunc, timeout time.Duration) (chan&lt;- struct{}, &lt;-chan struct{}) <span class="cov8" title="1">{
        if timeout &lt;= 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">activity := make(chan struct{}, 1)
        triggered := make(chan struct{}, 1)
        go func() </span><span class="cov8" title="1">{
                timer := time.NewTimer(timeout)
                defer timer.Stop()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case &lt;-timer.C:<span class="cov8" title="1">
                                select </span>{
                                case triggered &lt;- struct{}{}:<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                                <span class="cov8" title="1">cancel()
                                return</span>
                        case &lt;-activity:<span class="cov8" title="1">
                                if !timer.Stop() </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-timer.C:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                }
                                <span class="cov8" title="1">timer.Reset(timeout)</span>
                        }
                }
        }()
        <span class="cov8" title="1">return activity, triggered</span>
}

func signalActivity(activity chan&lt;- struct{}) <span class="cov8" title="1">{
        if activity == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case activity &lt;- struct{}{}:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"></span>
        }
}

func streamContextError(ctx context.Context, idleTriggered &lt;-chan struct{}) error <span class="cov8" title="1">{
        if idleTriggered != nil </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-idleTriggered:<span class="cov8" title="1">
                        return errors.New("perplexity stream idle timeout")</span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov8" title="1">{
                return errors.Wrap(ctx.Err(), "stream context canceled")
        }</span>
        <span class="cov0" title="0">return errors.New("stream context canceled")</span>
}

func retryDelay(resp *http.Response, attempt int, rng *rand.Rand) time.Duration <span class="cov8" title="1">{
        if resp != nil </span><span class="cov8" title="1">{
                if delay, ok := parseRetryAfter(resp.Header.Get("Retry-After")); ok </span><span class="cov8" title="1">{
                        return delay
                }</span>
        }
        <span class="cov8" title="1">backoff := time.Second &lt;&lt; attempt
        if backoff &gt; 32*time.Second </span><span class="cov0" title="0">{
                backoff = 32 * time.Second
        }</span>
        <span class="cov8" title="1">if rng == nil </span><span class="cov0" title="0">{
                return backoff
        }</span>
        <span class="cov8" title="1">jitterMax := backoff / 2
        if jitterMax &lt;= 0 </span><span class="cov0" title="0">{
                return backoff
        }</span>
        <span class="cov8" title="1">return backoff + time.Duration(rng.Int63n(int64(jitterMax)))</span>
}

func parseRetryAfter(value string) (time.Duration, bool) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if seconds, err := strconv.Atoi(trimmed); err == nil </span><span class="cov8" title="1">{
                if seconds &lt;= 0 </span><span class="cov8" title="1">{
                        return 0, false
                }</span>
                <span class="cov8" title="1">return time.Duration(seconds) * time.Second, true</span>
        }
        <span class="cov8" title="1">if parsed, err := http.ParseTime(trimmed); err == nil </span><span class="cov8" title="1">{
                delta := time.Until(parsed)
                if delta &gt; 0 </span><span class="cov8" title="1">{
                        return delta, true
                }</span>
        }
        <span class="cov8" title="1">return 0, false</span>
}

func sleepWithContext(ctx context.Context, delay time.Duration) error <span class="cov8" title="1">{
        if delay &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">timer := time.NewTimer(delay)
        defer timer.Stop()
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return errors.Wrap(ctx.Err(), "request canceled")</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return nil</span>
        }
}

func logRetry(stderr io.Writer, delay time.Duration, status int, err error) <span class="cov8" title="1">{
        if stderr == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if status &gt; 0 </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(stderr, "perplexity retry in %s after status %d\n", delay, status)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(stderr, "perplexity retry in %s after error: %v\n", delay, err)
                return
        }</span>
        <span class="cov8" title="1">_, _ = fmt.Fprintf(stderr, "perplexity retry in %s\n", delay)</span>
}

func readErrorBody(body io.ReadCloser) string <span class="cov8" title="1">{
        if body == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">defer body.Close()
        data, err := io.ReadAll(io.LimitReader(body, 8*1024))
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(data))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//go:build !windows

package agent

import (
        "os/exec"
        "syscall"
)

func applyProcessGroup(cmd *exec.Cmd) <span class="cov8" title="1">{
        if cmd == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if cmd.SysProcAttr == nil </span><span class="cov8" title="1">{
                cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        }</span>
        <span class="cov8" title="1">cmd.SysProcAttr.Setsid = true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package agent

import (
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
)

// OutputFiles defines file destinations for captured stdout and stderr.
type OutputFiles struct {
        StdoutPath string
        StderrPath string
}

// OutputCapture holds writers and file handles for captured output.
type OutputCapture struct {
        Stdout io.Writer
        Stderr io.Writer

        stdoutFile *os.File
        stderrFile *os.File
}

// CaptureOutput opens stdout/stderr files and returns writers that tee output.
func CaptureOutput(stdout, stderr io.Writer, files OutputFiles) (*OutputCapture, error) <span class="cov8" title="1">{
        stdoutPath := strings.TrimSpace(files.StdoutPath)
        if stdoutPath == "" </span><span class="cov8" title="1">{
                return nil, errors.New("stdout path is empty")
        }</span>
        <span class="cov8" title="1">stderrPath := strings.TrimSpace(files.StderrPath)
        if stderrPath == "" </span><span class="cov8" title="1">{
                return nil, errors.New("stderr path is empty")
        }</span>

        <span class="cov8" title="1">stdoutFile, err := openOutputFile(stdoutPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "open stdout file")
        }</span>
        <span class="cov8" title="1">stderrFile, err := openOutputFile(stderrPath)
        if err != nil </span><span class="cov8" title="1">{
                _ = stdoutFile.Close()
                return nil, errors.Wrap(err, "open stderr file")
        }</span>

        <span class="cov8" title="1">stdoutWriter := io.Writer(stdoutFile)
        if stdout != nil </span><span class="cov0" title="0">{
                stdoutWriter = io.MultiWriter(stdoutFile, stdout)
        }</span>
        <span class="cov8" title="1">stderrWriter := io.Writer(stderrFile)
        if stderr != nil </span><span class="cov0" title="0">{
                stderrWriter = io.MultiWriter(stderrFile, stderr)
        }</span>

        <span class="cov8" title="1">return &amp;OutputCapture{
                Stdout:     stdoutWriter,
                Stderr:     stderrWriter,
                stdoutFile: stdoutFile,
                stderrFile: stderrFile,
        }, nil</span>
}

// Close closes the underlying stdout/stderr files.
func (c *OutputCapture) Close() error <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return errors.New("output capture is nil")
        }</span>
        <span class="cov8" title="1">var firstErr error
        if c.stdoutFile != nil </span><span class="cov8" title="1">{
                if err := c.stdoutFile.Close(); err != nil </span><span class="cov0" title="0">{
                        firstErr = errors.Wrap(err, "close stdout file")
                }</span>
        }
        <span class="cov8" title="1">if c.stderrFile != nil </span><span class="cov8" title="1">{
                if err := c.stderrFile.Close(); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = errors.Wrap(err, "close stderr file")
                }</span>
        }
        <span class="cov8" title="1">return firstErr</span>
}

func openOutputFile(path string) (*os.File, error) <span class="cov8" title="1">{
        if strings.TrimSpace(path) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("output path is empty")
        }</span>
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "create output directory")
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "open output file")
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package xai implements the xAI REST backend adapter.
package xai

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/pkg/errors"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
)

const (
        // TypeName identifies the xAI agent type.
        TypeName = "xai"

        // DefaultBaseURL is the default xAI API base URL.
        DefaultBaseURL = "https://api.x.ai"
        // DefaultModel is the default xAI model when none is specified.
        DefaultModel = "grok-4"

        // Environment variable names.
        envAPIKey      = "XAI_API_KEY"
        envBaseURL     = "XAI_BASE_URL"
        envAPIBase     = "XAI_API_BASE"
        envAPIEndpoint = "XAI_API_ENDPOINT"
        envModel       = "XAI_MODEL"
)

const (
        defaultDialTimeout    = 10 * time.Second
        defaultHeaderTimeout  = 60 * time.Second
        defaultIdleTimeout    = 90 * time.Second
        defaultMaxIdleConns   = 100
        defaultMaxLineSize    = 1024 * 1024
        defaultUserAgent      = "conductor-loop/xai"
        streamContentTypeHint = "text/event-stream"
)

// Config configures the xAI agent backend.
type Config struct {
        APIKey     string
        BaseURL    string
        Model      string
        HTTPClient *http.Client
        UserAgent  string
}

// Agent implements the xAI REST backend.
type Agent struct {
        apiKey     string
        baseURL    string
        model      string
        userAgent  string
        httpClient *http.Client
}

// NewAgent builds an xAI agent backend from explicit configuration.
func NewAgent(cfg Config) (*Agent, error) <span class="cov8" title="1">{
        apiKey := strings.TrimSpace(cfg.APIKey)
        baseURL := strings.TrimSpace(cfg.BaseURL)
        model := strings.TrimSpace(cfg.Model)
        userAgent := strings.TrimSpace(cfg.UserAgent)

        if model == "" </span><span class="cov8" title="1">{
                model = DefaultModel
        }</span>
        <span class="cov8" title="1">if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = DefaultBaseURL
        }</span>
        <span class="cov8" title="1">if userAgent == "" </span><span class="cov8" title="1">{
                userAgent = defaultUserAgent
        }</span>

        <span class="cov8" title="1">client := cfg.HTTPClient
        if client == nil </span><span class="cov8" title="1">{
                client = defaultHTTPClient()
        }</span>

        <span class="cov8" title="1">return &amp;Agent{
                apiKey:     apiKey,
                baseURL:    baseURL,
                model:      model,
                userAgent:  userAgent,
                httpClient: client,
        }, nil</span>
}

// NewAgentFromEnvironment builds an xAI agent backend using environment values.
func NewAgentFromEnvironment(env map[string]string) (*Agent, error) <span class="cov8" title="1">{
        return NewAgent(Config{
                APIKey:  lookupEnv(env, envAPIKey),
                BaseURL: lookupEnv(env, envAPIEndpoint, envBaseURL, envAPIBase),
                Model:   lookupEnv(env, envModel),
        })
}</span>

// Type returns the agent type identifier.
func (a *Agent) Type() string <span class="cov8" title="1">{
        return TypeName
}</span>

// Execute runs the xAI request and streams output to stdout.
func (a *Agent) Execute(ctx context.Context, runCtx *agent.RunContext) error <span class="cov8" title="1">{
        if runCtx == nil </span><span class="cov8" title="1">{
                return errors.New("run context is nil")
        }</span>
        <span class="cov8" title="1">prompt := runCtx.Prompt
        if strings.TrimSpace(prompt) == "" </span><span class="cov8" title="1">{
                return errors.New("prompt is empty")
        }</span>

        <span class="cov8" title="1">capture, err := agent.CaptureOutput(os.Stdout, os.Stderr, agent.OutputFiles{
                StdoutPath: runCtx.StdoutPath,
                StderrPath: runCtx.StderrPath,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "capture output")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = capture.Close()
        }</span>()

        <span class="cov8" title="1">resolved, err := a.resolveConfig(runCtx.Environment)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := resolved.streamCompletion(ctx, prompt, capture.Stdout); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type resolvedConfig struct {
        apiKey     string
        model      string
        endpoint   string
        userAgent  string
        httpClient *http.Client
}

func (a *Agent) resolveConfig(env map[string]string) (*resolvedConfig, error) <span class="cov8" title="1">{
        apiKey := a.apiKey
        if apiKey == "" </span><span class="cov8" title="1">{
                apiKey = lookupEnv(env, envAPIKey)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(apiKey) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("xai api key is empty")
        }</span>

        <span class="cov8" title="1">baseURL := a.baseURL
        if override := lookupEnv(env, envAPIEndpoint, envBaseURL, envAPIBase); override != "" </span><span class="cov8" title="1">{
                baseURL = override
        }</span>
        <span class="cov8" title="1">endpoint, err := resolveEndpoint(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">model := a.model
        if override := lookupEnv(env, envModel); override != "" </span><span class="cov8" title="1">{
                model = override
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(model) == "" </span><span class="cov0" title="0">{
                model = DefaultModel
        }</span>

        <span class="cov8" title="1">client := a.httpClient
        if client == nil </span><span class="cov0" title="0">{
                client = defaultHTTPClient()
        }</span>

        <span class="cov8" title="1">userAgent := a.userAgent
        if userAgent == "" </span><span class="cov0" title="0">{
                userAgent = defaultUserAgent
        }</span>

        <span class="cov8" title="1">return &amp;resolvedConfig{
                apiKey:     apiKey,
                model:      model,
                endpoint:   endpoint,
                userAgent:  userAgent,
                httpClient: client,
        }, nil</span>
}

func (c *resolvedConfig) streamCompletion(ctx context.Context, prompt string, stdout io.Writer) error <span class="cov8" title="1">{
        reqBody := chatCompletionRequest{
                Model: c.model,
                Messages: []chatMessage{
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
                Stream: true,
        }

        payload, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "encode request")
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "build request")
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.apiKey)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", streamContentTypeHint)
        req.Header.Set("User-Agent", c.userAgent)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "send request")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(io.LimitReader(resp.Body, 16*1024))
                return errors.Errorf("xai request failed: status %d: %s", resp.StatusCode, strings.TrimSpace(string(body)))
        }</span>

        <span class="cov8" title="1">if strings.Contains(strings.ToLower(resp.Header.Get("Content-Type")), streamContentTypeHint) </span><span class="cov8" title="1">{
                return streamResponse(resp.Body, stdout)
        }</span>

        <span class="cov8" title="1">return decodeSingleResponse(resp.Body, stdout)</span>
}

func defaultHTTPClient() *http.Client <span class="cov8" title="1">{
        transport := &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   defaultDialTimeout,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          defaultMaxIdleConns,
                IdleConnTimeout:       defaultIdleTimeout,
                TLSHandshakeTimeout:   defaultDialTimeout,
                ResponseHeaderTimeout: defaultHeaderTimeout,
                ExpectContinueTimeout: 1 * time.Second,
        }

        return &amp;http.Client{
                Transport: transport,
        }
}</span>

func resolveEndpoint(baseURL string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(baseURL)
        if trimmed == "" </span><span class="cov0" title="0">{
                trimmed = DefaultBaseURL
        }</span>
        <span class="cov8" title="1">u, err := url.Parse(trimmed)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, "parse base url")
        }</span>

        <span class="cov8" title="1">path := strings.TrimRight(u.Path, "/")
        switch </span>{
        case strings.HasSuffix(path, "/v1/chat/completions"):<span class="cov8" title="1">
                return u.String(), nil</span>
        case strings.HasSuffix(path, "/v1"):<span class="cov8" title="1">
                u.Path = path + "/chat/completions"</span>
        default:<span class="cov8" title="1">
                if path == "" </span><span class="cov8" title="1">{
                        u.Path = "/v1/chat/completions"
                }</span> else<span class="cov0" title="0"> {
                        u.Path = path + "/v1/chat/completions"
                }</span>
        }
        <span class="cov8" title="1">return u.String(), nil</span>
}

func lookupEnv(env map[string]string, keys ...string) string <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if env != nil </span><span class="cov8" title="1">{
                        if value, ok := env[key]; ok </span><span class="cov8" title="1">{
                                if strings.TrimSpace(value) != "" </span><span class="cov8" title="1">{
                                        return strings.TrimSpace(value)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if value, ok := os.LookupEnv(key); ok </span><span class="cov8" title="1">{
                        if strings.TrimSpace(value) != "" </span><span class="cov8" title="1">{
                                return strings.TrimSpace(value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func streamResponse(reader io.Reader, stdout io.Writer) error <span class="cov8" title="1">{
        scanner := bufio.NewScanner(reader)
        scanner.Buffer(make([]byte, 0, 64*1024), defaultMaxLineSize)

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, ":") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.HasPrefix(line, "data:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">payload := strings.TrimSpace(strings.TrimPrefix(line, "data:"))
                if payload == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if payload == "[DONE]" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if err := writeChunk(payload, stdout); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "read stream")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func writeChunk(payload string, stdout io.Writer) error <span class="cov8" title="1">{
        var chunk chatCompletionChunk
        if err := json.Unmarshal([]byte(payload), &amp;chunk); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "decode stream chunk")
        }</span>
        <span class="cov8" title="1">if chunk.Error != nil </span><span class="cov8" title="1">{
                return errors.New(strings.TrimSpace(chunk.Error.Message))
        }</span>
        <span class="cov8" title="1">content := chunk.Content()
        if content == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(stdout, content); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write stream content")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func decodeSingleResponse(reader io.Reader, stdout io.Writer) error <span class="cov8" title="1">{
        body, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "read response")
        }</span>
        <span class="cov8" title="1">var resp chatCompletionResponse
        if err := json.Unmarshal(body, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "decode response")
        }</span>
        <span class="cov8" title="1">if resp.Error != nil </span><span class="cov8" title="1">{
                return errors.New(strings.TrimSpace(resp.Error.Message))
        }</span>
        <span class="cov8" title="1">content := resp.Content()
        if strings.TrimSpace(content) == "" </span><span class="cov8" title="1">{
                return errors.New("xai response missing content")
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(stdout, content); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write response content")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type chatCompletionRequest struct {
        Model    string        `json:"model"`
        Messages []chatMessage `json:"messages"`
        Stream   bool          `json:"stream,omitempty"`
}

type chatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type chatCompletionChunk struct {
        Choices []chatChoice `json:"choices"`
        Error   *apiError    `json:"error,omitempty"`
}

func (c chatCompletionChunk) Content() string <span class="cov8" title="1">{
        if len(c.Choices) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">choice := c.Choices[0]
        if choice.Delta.Content != "" </span><span class="cov8" title="1">{
                return choice.Delta.Content
        }</span>
        <span class="cov8" title="1">if choice.Message.Content != "" </span><span class="cov8" title="1">{
                return choice.Message.Content
        }</span>
        <span class="cov0" title="0">if choice.Text != "" </span><span class="cov0" title="0">{
                return choice.Text
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type chatCompletionResponse struct {
        Choices []chatChoice `json:"choices"`
        Error   *apiError    `json:"error,omitempty"`
}

func (c chatCompletionResponse) Content() string <span class="cov8" title="1">{
        if len(c.Choices) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">choice := c.Choices[0]
        if choice.Message.Content != "" </span><span class="cov8" title="1">{
                return choice.Message.Content
        }</span>
        <span class="cov8" title="1">if choice.Text != "" </span><span class="cov8" title="1">{
                return choice.Text
        }</span>
        <span class="cov0" title="0">if choice.Delta.Content != "" </span><span class="cov0" title="0">{
                return choice.Delta.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type chatChoice struct {
        Delta   chatDelta   `json:"delta,omitempty"`
        Message chatMessage `json:"message,omitempty"`
        Text    string      `json:"text,omitempty"`
}

type chatDelta struct {
        Content string `json:"content,omitempty"`
        Role    string `json:"role,omitempty"`
}

type apiError struct {
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "context"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/pkg/errors"
)

// RunDiscovery polls a root directory for new runs.
type RunDiscovery struct {
        rootDir    string
        knownRuns  map[string]bool
        ticker     *time.Ticker
        newRunChan chan string
}

// NewRunDiscovery creates a RunDiscovery.
func NewRunDiscovery(rootDir string, interval time.Duration) (*RunDiscovery, error) <span class="cov8" title="1">{
        cleanDir := filepath.Clean(strings.TrimSpace(rootDir))
        if cleanDir == "." || cleanDir == "" </span><span class="cov8" title="1">{
                return nil, errors.New("root directory is empty")
        }</span>
        <span class="cov8" title="1">if interval &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("discovery interval must be positive")
        }</span>
        <span class="cov8" title="1">return &amp;RunDiscovery{
                rootDir:    cleanDir,
                knownRuns:  make(map[string]bool),
                newRunChan: make(chan string, 32),
        }, nil</span>
}

// NewRuns returns a channel emitting newly discovered run IDs.
func (d *RunDiscovery) NewRuns() &lt;-chan string <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.newRunChan</span>
}

// Poll starts polling until context cancellation.
func (d *RunDiscovery) Poll(ctx context.Context, interval time.Duration) <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if interval &lt;= 0 </span><span class="cov0" title="0">{
                interval = time.Second
        }</span>
        <span class="cov8" title="1">d.ticker = time.NewTicker(interval)
        defer d.ticker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-d.ticker.C:<span class="cov8" title="1">
                        _ = d.scan()</span>
                }
        }
}

func (d *RunDiscovery) scan() error <span class="cov8" title="1">{
        runs, err := listRunIDs(d.rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "list runs")
        }</span>
        <span class="cov8" title="1">for _, name := range runs </span><span class="cov8" title="1">{
                if name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if d.knownRuns[name] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">d.knownRuns[name] = true
                select </span>{
                case d.newRunChan &lt;- name:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func listRunIDs(rootDir string) ([]string, error) <span class="cov8" title="1">{
        cleanDir := filepath.Clean(strings.TrimSpace(rootDir))
        if cleanDir == "." || cleanDir == "" </span><span class="cov0" title="0">{
                return nil, errors.New("root directory is empty")
        }</span>
        <span class="cov8" title="1">var runs []string
        walkErr := filepath.WalkDir(cleanDir, func(path string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if d.Name() != "run-info.yaml" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">runID := filepath.Base(filepath.Dir(path))
                if runID != "" </span><span class="cov8" title="1">{
                        runs = append(runs, runID)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if walkErr != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(walkErr) </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(walkErr, "walk runs")</span>
        }
        <span class="cov8" title="1">return runs, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/messagebus"
        "github.com/jonnyzzz/conductor-loop/internal/runner"
        "github.com/jonnyzzz/conductor-loop/internal/storage"
        "github.com/pkg/errors"
)

const maxJSONBodySize = 1 &lt;&lt; 20

// TaskCreateRequest defines the payload for task creation.
type TaskCreateRequest struct {
        ProjectID string            `json:"project_id"`
        TaskID    string            `json:"task_id"`
        AgentType string            `json:"agent_type"`
        Prompt    string            `json:"prompt"`
        Config    map[string]string `json:"config,omitempty"`
}

// TaskCreateResponse defines the response for task creation.
type TaskCreateResponse struct {
        ProjectID string `json:"project_id"`
        TaskID    string `json:"task_id"`
        Status    string `json:"status"`
}

// TaskResponse defines the task response payload.
type TaskResponse struct {
        ProjectID    string        `json:"project_id"`
        TaskID       string        `json:"task_id"`
        Status       string        `json:"status"`
        LastActivity time.Time     `json:"last_activity"`
        Runs         []RunResponse `json:"runs,omitempty"`
}

// RunResponse defines run metadata returned by the API.
type RunResponse struct {
        RunID     string    `json:"run_id"`
        ProjectID string    `json:"project_id"`
        TaskID    string    `json:"task_id"`
        Status    string    `json:"status"`
        StartTime time.Time `json:"start_time"`
        EndTime   time.Time `json:"end_time,omitempty"`
        ExitCode  int       `json:"exit_code,omitempty"`
}

// MessageResponse defines the message bus entry payload.
type MessageResponse struct {
        MsgID        string    `json:"msg_id"`
        Timestamp    time.Time `json:"timestamp"`
        Type         string    `json:"type"`
        ProjectID    string    `json:"project_id"`
        TaskID       string    `json:"task_id,omitempty"`
        RunID        string    `json:"run_id,omitempty"`
        ParentMsgIDs []string  `json:"parents,omitempty"`
        Attachment   string    `json:"attachment_path,omitempty"`
        Body         string    `json:"body"`
}

type handlerFunc func(http.ResponseWriter, *http.Request) *apiError

func (s *Server) wrap(handler handlerFunc) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if handler == nil </span><span class="cov0" title="0">{
                        s.writeError(w, apiErrorInternal("handler is nil", nil))
                        return
                }</span>
                <span class="cov8" title="1">if err := handler(w, r); err != nil </span><span class="cov8" title="1">{
                        s.writeError(w, err)
                }</span>
        })
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusOK, map[string]string{"status": "ok"})</span>
}

func (s *Server) handleVersion(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusOK, map[string]string{"version": s.version})</span>
}

func (s *Server) handleTasks(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                return s.handleTaskList(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                return s.handleTaskCreate(w, r)</span>
        default:<span class="cov0" title="0">
                return apiErrorMethodNotAllowed()</span>
        }
}

func (s *Server) handleTaskByID(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        segments := pathSegments(r.URL.Path, "/api/v1/tasks/")
        if len(segments) != 1 </span><span class="cov0" title="0">{
                return apiErrorNotFound("task not found")
        }</span>
        <span class="cov8" title="1">taskID := segments[0]
        projectID := strings.TrimSpace(r.URL.Query().Get("project_id"))

        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                return s.handleTaskGet(w, r, projectID, taskID)</span>
        case http.MethodDelete:<span class="cov8" title="1">
                return s.handleTaskCancel(w, r, projectID, taskID)</span>
        default:<span class="cov0" title="0">
                return apiErrorMethodNotAllowed()</span>
        }
}

func (s *Server) handleRuns(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov8" title="1">runs, err := listRunResponses(s.rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("list runs", err)
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusOK, map[string][]RunResponse{"runs": runs})</span>
}

func (s *Server) handleRunByID(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        segments := pathSegments(r.URL.Path, "/api/v1/runs/")
        if len(segments) == 0 </span><span class="cov8" title="1">{
                return apiErrorNotFound("run not found")
        }</span>
        <span class="cov8" title="1">runID := segments[0]
        if len(segments) == 1 </span><span class="cov8" title="1">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        return apiErrorMethodNotAllowed()
                }</span>
                <span class="cov8" title="1">return s.handleRunGet(w, r, runID)</span>
        }
        <span class="cov8" title="1">if len(segments) == 2 </span><span class="cov8" title="1">{
                switch segments[1] </span>{
                case "info":<span class="cov8" title="1">
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                return apiErrorMethodNotAllowed()
                        }</span>
                        <span class="cov8" title="1">return s.handleRunInfo(w, r, runID)</span>
                case "stop":<span class="cov8" title="1">
                        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                                return apiErrorMethodNotAllowed()
                        }</span>
                        <span class="cov8" title="1">return s.handleRunStop(w, r, runID)</span>
                case "stream":<span class="cov0" title="0">
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                return apiErrorMethodNotAllowed()
                        }</span>
                        <span class="cov0" title="0">return s.streamRun(w, r, runID)</span>
                default:<span class="cov8" title="1">
                        return apiErrorNotFound("run not found")</span>
                }
        }
        <span class="cov0" title="0">return apiErrorNotFound("run not found")</span>
}

func (s *Server) handleMessages(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov8" title="1">projectID := strings.TrimSpace(r.URL.Query().Get("project_id"))
        if projectID == "" </span><span class="cov0" title="0">{
                return apiErrorBadRequest("project_id is required")
        }</span>
        <span class="cov8" title="1">after := strings.TrimSpace(r.URL.Query().Get("after"))
        taskID := strings.TrimSpace(r.URL.Query().Get("task_id"))

        busPath := filepath.Join(s.rootDir, projectID, "PROJECT-MESSAGE-BUS.md")
        if taskID != "" </span><span class="cov0" title="0">{
                busPath = filepath.Join(s.rootDir, projectID, taskID, "TASK-MESSAGE-BUS.md")
        }</span>
        <span class="cov8" title="1">bus, err := messagebus.NewMessageBus(busPath)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("open message bus", err)
        }</span>
        <span class="cov8" title="1">messages, err := bus.ReadMessages(after)
        if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, messagebus.ErrSinceIDNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("message id not found")
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("read message bus", err)</span>
        }
        <span class="cov8" title="1">resp := make([]MessageResponse, 0, len(messages))
        for _, msg := range messages </span><span class="cov8" title="1">{
                if msg == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">resp = append(resp, MessageResponse{
                        MsgID:        msg.MsgID,
                        Timestamp:    msg.Timestamp,
                        Type:         msg.Type,
                        ProjectID:    msg.ProjectID,
                        TaskID:       msg.TaskID,
                        RunID:        msg.RunID,
                        ParentMsgIDs: msg.ParentMsgIDs,
                        Attachment:   msg.Attachment,
                        Body:         msg.Body,
                })</span>
        }
        <span class="cov8" title="1">return writeJSON(w, http.StatusOK, map[string][]MessageResponse{"messages": resp})</span>
}

func (s *Server) handleTaskCreate(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        var req TaskCreateRequest
        if err := decodeJSON(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateIdentifier(req.ProjectID, "project_id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateIdentifier(req.TaskID, "task_id"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.AgentType) == "" </span><span class="cov8" title="1">{
                return apiErrorBadRequest("agent_type is required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Prompt) == "" </span><span class="cov0" title="0">{
                return apiErrorBadRequest("prompt is required")
        }</span>

        <span class="cov8" title="1">taskDir := filepath.Join(s.rootDir, req.ProjectID, req.TaskID)
        if err := os.MkdirAll(taskDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("create task directory", err)
        }</span>
        <span class="cov8" title="1">prompt := strings.TrimSpace(req.Prompt)
        if !strings.HasSuffix(prompt, "\n") </span><span class="cov8" title="1">{
                prompt += "\n"
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(filepath.Join(taskDir, "TASK.md"), []byte(prompt), 0o644); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("write TASK.md", err)
        }</span>

        <span class="cov8" title="1">if s.startTasks </span><span class="cov0" title="0">{
                go s.startTask(req)
        }</span>

        <span class="cov8" title="1">resp := TaskCreateResponse{
                ProjectID: req.ProjectID,
                TaskID:    req.TaskID,
                Status:    "started",
        }
        return writeJSON(w, http.StatusCreated, resp)</span>
}

func (s *Server) handleTaskList(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        tasks, err := listTasks(s.rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("list tasks", err)
        }</span>
        <span class="cov8" title="1">resp := make([]TaskResponse, 0, len(tasks))
        for _, task := range tasks </span><span class="cov8" title="1">{
                resp = append(resp, TaskResponse{
                        ProjectID:    task.ProjectID,
                        TaskID:       task.TaskID,
                        Status:       task.Status,
                        LastActivity: task.LastActivity,
                })
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusOK, map[string][]TaskResponse{"tasks": resp})</span>
}

func (s *Server) handleTaskGet(w http.ResponseWriter, r *http.Request, projectID, taskID string) *apiError <span class="cov8" title="1">{
        if err := validateIdentifier(taskID, "task_id"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">var task taskInfo
        var err error
        if projectID != "" </span><span class="cov8" title="1">{
                if err := validateIdentifier(projectID, "project_id"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">task, err = getTask(s.rootDir, projectID, taskID)</span>
        } else<span class="cov0" title="0"> {
                task, err = findTask(s.rootDir, taskID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, errNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("task not found")
                }</span>
                <span class="cov0" title="0">if stderrors.Is(err, errAmbiguous) </span><span class="cov0" title="0">{
                        return apiErrorConflict("multiple tasks found", map[string]string{"task_id": taskID})
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("get task", err)</span>
        }

        <span class="cov8" title="1">runs, err := listTaskRuns(task.Path)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("list task runs", err)
        }</span>
        <span class="cov8" title="1">resp := TaskResponse{
                ProjectID:    task.ProjectID,
                TaskID:       task.TaskID,
                Status:       task.Status,
                LastActivity: task.LastActivity,
                Runs:         runs,
        }
        return writeJSON(w, http.StatusOK, resp)</span>
}

func (s *Server) handleTaskCancel(w http.ResponseWriter, r *http.Request, projectID, taskID string) *apiError <span class="cov8" title="1">{
        if err := validateIdentifier(taskID, "task_id"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">var task taskInfo
        var err error
        if projectID != "" </span><span class="cov8" title="1">{
                if err := validateIdentifier(projectID, "project_id"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">task, err = getTask(s.rootDir, projectID, taskID)</span>
        } else<span class="cov0" title="0"> {
                task, err = findTask(s.rootDir, taskID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, errNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("task not found")
                }</span>
                <span class="cov0" title="0">if stderrors.Is(err, errAmbiguous) </span><span class="cov0" title="0">{
                        return apiErrorConflict("multiple tasks found", map[string]string{"task_id": taskID})
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("get task", err)</span>
        }

        <span class="cov8" title="1">if err := os.WriteFile(filepath.Join(task.Path, "DONE"), []byte(""), 0o644); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("write DONE", err)
        }</span>

        <span class="cov8" title="1">stopped, err := stopTaskRuns(task.Path)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("stop task", err)
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusAccepted, map[string]int{"stopped_runs": stopped})</span>
}

func (s *Server) handleRunGet(w http.ResponseWriter, r *http.Request, runID string) *apiError <span class="cov8" title="1">{
        info, err := getRunInfo(s.rootDir, runID)
        if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, errNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("run not found")
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("get run", err)</span>
        }
        <span class="cov8" title="1">resp := runInfoToResponse(info)
        return writeJSON(w, http.StatusOK, resp)</span>
}

func (s *Server) handleRunInfo(w http.ResponseWriter, r *http.Request, runID string) *apiError <span class="cov8" title="1">{
        path, err := findRunInfoPath(s.rootDir, runID)
        if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, errNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("run not found")
                }</span>
                <span class="cov8" title="1">if stderrors.Is(err, errAmbiguous) </span><span class="cov8" title="1">{
                        return apiErrorConflict("multiple runs found", map[string]string{"run_id": runID})
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("get run info", err)</span>
        }
        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("read run-info", err)
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/x-yaml")
        w.WriteHeader(http.StatusOK)
        if _, err := w.Write(data); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("write response", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Server) handleRunStop(w http.ResponseWriter, r *http.Request, runID string) *apiError <span class="cov8" title="1">{
        info, err := getRunInfo(s.rootDir, runID)
        if err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, errNotFound) </span><span class="cov8" title="1">{
                        return apiErrorNotFound("run not found")
                }</span>
                <span class="cov0" title="0">return apiErrorInternal("get run", err)</span>
        }
        <span class="cov8" title="1">if !info.EndTime.IsZero() </span><span class="cov8" title="1">{
                return apiErrorConflict("run already finished", map[string]string{"run_id": runID})
        }</span>
        <span class="cov8" title="1">if err := runner.TerminateProcessGroup(info.PGID); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("stop run", err)
        }</span>
        <span class="cov8" title="1">return writeJSON(w, http.StatusAccepted, map[string]string{"status": "stopping"})</span>
}

func (s *Server) startTask(req TaskCreateRequest) <span class="cov8" title="1">{
        opts := runner.TaskOptions{
                RootDir:     s.rootDir,
                ConfigPath:  s.configPath,
                Agent:       req.AgentType,
                Prompt:      req.Prompt,
                Environment: req.Config,
        }
        if err := runner.RunTask(req.ProjectID, req.TaskID, opts); err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("task %s/%s failed: %v", req.ProjectID, req.TaskID, err)
        }</span>
}

func runInfoToResponse(info *storage.RunInfo) RunResponse <span class="cov8" title="1">{
        if info == nil </span><span class="cov0" title="0">{
                return RunResponse{}
        }</span>
        <span class="cov8" title="1">return RunResponse{
                RunID:     info.RunID,
                ProjectID: info.ProjectID,
                TaskID:    info.TaskID,
                Status:    info.Status,
                StartTime: info.StartTime,
                EndTime:   info.EndTime,
                ExitCode:  info.ExitCode,
        }</span>
}

func decodeJSON(r *http.Request, dest interface{}) *apiError <span class="cov8" title="1">{
        if r == nil || r.Body == nil </span><span class="cov0" title="0">{
                return apiErrorBadRequest("request body is required")
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()
        dec := json.NewDecoder(io.LimitReader(r.Body, maxJSONBodySize))
        dec.DisallowUnknownFields()
        if err := dec.Decode(dest); err != nil </span><span class="cov8" title="1">{
                return apiErrorBadRequest(fmt.Sprintf("invalid json: %v", err))
        }</span>
        <span class="cov8" title="1">if err := dec.Decode(&amp;struct{}{}); err != io.EOF </span><span class="cov0" title="0">{
                return apiErrorBadRequest("unexpected trailing data")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeJSON(w http.ResponseWriter, status int, payload interface{}) *apiError <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                return apiErrorInternal("response writer is nil", nil)
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if payload == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := json.NewEncoder(w).Encode(payload); err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("encode response", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateIdentifier(value, name string) *apiError <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov8" title="1">{
                return apiErrorBadRequest(fmt.Sprintf("%s is required", name))
        }</span>
        <span class="cov8" title="1">if strings.Contains(trimmed, "/") || strings.Contains(trimmed, "\\") </span><span class="cov8" title="1">{
                return apiErrorBadRequest(fmt.Sprintf("%s must not contain path separators", name))
        }</span>
        <span class="cov8" title="1">if strings.Contains(trimmed, "..") </span><span class="cov8" title="1">{
                return apiErrorBadRequest(fmt.Sprintf("%s must not contain ..", name))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func pathSegments(path, prefix string) []string <span class="cov8" title="1">{
        if !strings.HasPrefix(path, prefix) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">trimmed := strings.Trim(strings.TrimPrefix(path, prefix), "/")
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(trimmed, "/")
        filtered := parts[:0]
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filtered = append(filtered, part)</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// storage helpers

type taskInfo struct {
        ProjectID    string
        TaskID       string
        Path         string
        Status       string
        LastActivity time.Time
}

var (
        errNotFound  = stderrors.New("not found")
        errAmbiguous = stderrors.New("ambiguous")
)

func listTasks(root string) ([]taskInfo, error) <span class="cov8" title="1">{
        root = filepath.Clean(strings.TrimSpace(root))
        if root == "." || root == "" </span><span class="cov0" title="0">{
                return nil, stderrors.New("root dir is empty")
        }</span>
        <span class="cov8" title="1">entries, err := os.ReadDir(root)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []taskInfo{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "read root dir")</span>
        }

        <span class="cov8" title="1">var tasks []taskInfo
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">projectID := entry.Name()
                projectDir := filepath.Join(root, projectID)
                projectTasks, err := listProjectTasks(projectID, projectDir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tasks = append(tasks, projectTasks...)</span>
        }
        <span class="cov8" title="1">return tasks, nil</span>
}

func listProjectTasks(projectID, projectDir string) ([]taskInfo, error) <span class="cov8" title="1">{
        taskEntries, err := os.ReadDir(projectDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "read project dir %s", projectID)
        }</span>
        <span class="cov8" title="1">var tasks []taskInfo
        for _, entry := range taskEntries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">taskID := entry.Name()
                taskPath := filepath.Join(projectDir, taskID)
                if _, err := os.Stat(filepath.Join(taskPath, "TASK.md")); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, errors.Wrapf(err, "stat TASK.md for %s/%s", projectID, taskID)</span>
                }
                <span class="cov8" title="1">info, err := buildTaskInfo(projectID, taskID, taskPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tasks = append(tasks, info)</span>
        }
        <span class="cov8" title="1">return tasks, nil</span>
}

func getTask(root, projectID, taskID string) (taskInfo, error) <span class="cov8" title="1">{
        root = filepath.Clean(strings.TrimSpace(root))
        if root == "." || root == "" </span><span class="cov0" title="0">{
                return taskInfo{}, stderrors.New("root dir is empty")
        }</span>
        <span class="cov8" title="1">taskPath := filepath.Join(root, projectID, taskID)
        if _, err := os.Stat(filepath.Join(taskPath, "TASK.md")); err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return taskInfo{}, errNotFound
                }</span>
                <span class="cov0" title="0">return taskInfo{}, errors.Wrap(err, "stat TASK.md")</span>
        }
        <span class="cov8" title="1">info, err := buildTaskInfo(projectID, taskID, taskPath)
        if err != nil </span><span class="cov0" title="0">{
                return taskInfo{}, err
        }</span>
        <span class="cov8" title="1">return info, nil</span>
}

func findTask(root, taskID string) (taskInfo, error) <span class="cov8" title="1">{
        matches := make([]taskInfo, 0, 1)
        tasks, err := listTasks(root)
        if err != nil </span><span class="cov0" title="0">{
                return taskInfo{}, err
        }</span>
        <span class="cov8" title="1">for _, task := range tasks </span><span class="cov8" title="1">{
                if task.TaskID == taskID </span><span class="cov8" title="1">{
                        matches = append(matches, task)
                }</span>
        }
        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov0" title="0">{
                return taskInfo{}, errNotFound
        }</span>
        <span class="cov8" title="1">if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return taskInfo{}, errAmbiguous
        }</span>
        <span class="cov0" title="0">return matches[0], nil</span>
}

func buildTaskInfo(projectID, taskID, taskPath string) (taskInfo, error) <span class="cov8" title="1">{
        status := "idle"
        if _, err := os.Stat(filepath.Join(taskPath, "DONE")); err == nil </span><span class="cov0" title="0">{
                status = "completed"
        }</span>
        <span class="cov8" title="1">runs, err := listTaskRuns(taskPath)
        if err != nil </span><span class="cov0" title="0">{
                return taskInfo{}, err
        }</span>
        <span class="cov8" title="1">lastActivity := time.Time{}
        for _, run := range runs </span><span class="cov8" title="1">{
                candidate := run.EndTime
                if candidate.IsZero() </span><span class="cov8" title="1">{
                        candidate = run.StartTime
                }</span>
                <span class="cov8" title="1">if candidate.After(lastActivity) </span><span class="cov8" title="1">{
                        lastActivity = candidate
                }</span>
                <span class="cov8" title="1">if run.EndTime.IsZero() </span><span class="cov8" title="1">{
                        status = "running"
                }</span>
        }
        <span class="cov8" title="1">if lastActivity.IsZero() </span><span class="cov8" title="1">{
                if info, err := os.Stat(filepath.Join(taskPath, "TASK.md")); err == nil </span><span class="cov8" title="1">{
                        lastActivity = info.ModTime()
                }</span>
        }
        <span class="cov8" title="1">return taskInfo{
                ProjectID:    projectID,
                TaskID:       taskID,
                Path:         taskPath,
                Status:       status,
                LastActivity: lastActivity,
        }, nil</span>
}

func listTaskRuns(taskPath string) ([]RunResponse, error) <span class="cov8" title="1">{
        runsDir := filepath.Join(taskPath, "runs")
        entries, err := os.ReadDir(runsDir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return []RunResponse{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "read runs directory")</span>
        }
        <span class="cov8" title="1">responses := make([]RunResponse, 0, len(entries))
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">path := filepath.Join(runsDir, entry.Name(), "run-info.yaml")
                info, err := storage.ReadRunInfo(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "read run-info for run %s", entry.Name())
                }</span>
                <span class="cov8" title="1">responses = append(responses, runInfoToResponse(info))</span>
        }
        <span class="cov8" title="1">sort.Slice(responses, func(i, j int) bool </span><span class="cov0" title="0">{
                return responses[i].RunID &lt; responses[j].RunID
        }</span>)
        <span class="cov8" title="1">return responses, nil</span>
}

func listRunResponses(root string) ([]RunResponse, error) <span class="cov8" title="1">{
        root = filepath.Clean(strings.TrimSpace(root))
        if root == "." || root == "" </span><span class="cov8" title="1">{
                return nil, stderrors.New("root dir is empty")
        }</span>
        <span class="cov8" title="1">var runs []RunResponse
        walkErr := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if d.Name() != "run-info.yaml" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">info, err := storage.ReadRunInfo(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">runs = append(runs, runInfoToResponse(info))
                return nil</span>
        })
        <span class="cov8" title="1">if walkErr != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(walkErr) </span><span class="cov8" title="1">{
                        return []RunResponse{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(walkErr, "walk run-info")</span>
        }
        <span class="cov8" title="1">sort.Slice(runs, func(i, j int) bool </span><span class="cov0" title="0">{
                return runs[i].RunID &lt; runs[j].RunID
        }</span>)
        <span class="cov8" title="1">return runs, nil</span>
}

func getRunInfo(root, runID string) (*storage.RunInfo, error) <span class="cov8" title="1">{
        path, err := findRunInfoPath(root, runID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info, err := storage.ReadRunInfo(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "read run-info")
        }</span>
        <span class="cov8" title="1">return info, nil</span>
}

func findRunInfoPath(root, runID string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(runID)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "", stderrors.New("run id is empty")
        }</span>
        <span class="cov8" title="1">pattern := filepath.Join(root, "*", "*", "runs", trimmed, "run-info.yaml")
        matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "glob run-info path")
        }</span>
        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                return "", errNotFound
        }</span>
        <span class="cov8" title="1">if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return "", errAmbiguous
        }</span>
        <span class="cov8" title="1">return matches[0], nil</span>
}

func stopTaskRuns(taskPath string) (int, error) <span class="cov8" title="1">{
        runs, err := listTaskRunInfos(taskPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">stopped := 0
        for _, info := range runs </span><span class="cov8" title="1">{
                if info.EndTime.IsZero() </span><span class="cov8" title="1">{
                        if err := runner.TerminateProcessGroup(info.PGID); err != nil </span><span class="cov0" title="0">{
                                return stopped, err
                        }</span>
                        <span class="cov8" title="1">stopped++</span>
                }
        }
        <span class="cov8" title="1">return stopped, nil</span>
}

func listTaskRunInfos(taskPath string) ([]*storage.RunInfo, error) <span class="cov8" title="1">{
        runsDir := filepath.Join(taskPath, "runs")
        entries, err := os.ReadDir(runsDir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return []*storage.RunInfo{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "read runs directory")</span>
        }
        <span class="cov8" title="1">infos := make([]*storage.RunInfo, 0, len(entries))
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">path := filepath.Join(runsDir, entry.Name(), "run-info.yaml")
                info, err := storage.ReadRunInfo(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "read run-info for run %s", entry.Name())
                }</span>
                <span class="cov8" title="1">infos = append(infos, info)</span>
        }
        <span class="cov8" title="1">return infos, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strings"
        "time"
)

type apiError struct {
        Status  int
        Code    string
        Message string
        Details map[string]string
        Err     error
}

type errorResponse struct {
        Error errorPayload `json:"error"`
}

type errorPayload struct {
        Code    string            `json:"code"`
        Message string            `json:"message"`
        Details map[string]string `json:"details,omitempty"`
}

func apiErrorBadRequest(message string) *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusBadRequest, Code: "BAD_REQUEST", Message: message}
}</span>

func apiErrorNotFound(message string) *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusNotFound, Code: "NOT_FOUND", Message: message}
}</span>

func apiErrorConflict(message string, details map[string]string) *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusConflict, Code: "CONFLICT", Message: message, Details: details}
}</span>

func apiErrorUnauthorized(message string) *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusUnauthorized, Code: "UNAUTHORIZED", Message: message}
}</span>

func apiErrorMethodNotAllowed() *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusMethodNotAllowed, Code: "METHOD_NOT_ALLOWED", Message: "method not allowed"}
}</span>

func apiErrorInternal(message string, err error) *apiError <span class="cov8" title="1">{
        return &amp;apiError{Status: http.StatusInternalServerError, Code: "INTERNAL", Message: message, Err: err}
}</span>

func (s *Server) writeError(w http.ResponseWriter, err *apiError) <span class="cov8" title="1">{
        if err == nil || w == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">status := err.Status
        if status == 0 </span><span class="cov0" title="0">{
                status = http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">code := err.Code
        if code == "" </span><span class="cov0" title="0">{
                code = "INTERNAL"
        }</span>
        <span class="cov8" title="1">message := err.Message
        if message == "" </span><span class="cov0" title="0">{
                message = http.StatusText(status)
        }</span>
        <span class="cov8" title="1">if err.Err != nil &amp;&amp; s != nil &amp;&amp; s.logger != nil </span><span class="cov0" title="0">{
                s.logger.Printf("api error: %s: %v", message, err.Err)
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        payload := errorResponse{
                Error: errorPayload{
                        Code:    code,
                        Message: message,
                        Details: err.Details,
                },
        }
        _ = json.NewEncoder(w).Encode(payload)</span>
}

func (s *Server) withLogging(next http.Handler) http.Handler <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return next
        }</span>
        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := s.now()
                recorder := &amp;responseRecorder{ResponseWriter: w}
                next.ServeHTTP(recorder, r)
                duration := s.now().Sub(start)
                status := recorder.status
                if status == 0 </span><span class="cov0" title="0">{
                        status = http.StatusOK
                }</span>
                <span class="cov8" title="1">if s.logger != nil </span><span class="cov8" title="1">{
                        s.logger.Printf("%s %s %d %dB %s", r.Method, r.URL.Path, status, recorder.bytes, duration.Truncate(time.Millisecond))
                }</span>
        })
}

func (s *Server) withCORS(next http.Handler) http.Handler <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return next
        }</span>
        <span class="cov8" title="1">origins := s.apiConfig.CORSOrigins
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                origin := strings.TrimSpace(r.Header.Get("Origin"))
                allowedOrigin := ""
                if origin != "" &amp;&amp; originAllowed(origin, origins) </span><span class="cov8" title="1">{
                        if containsWildcard(origins) </span><span class="cov8" title="1">{
                                allowedOrigin = "*"
                        }</span> else<span class="cov0" title="0"> {
                                allowedOrigin = origin
                        }</span>
                }
                <span class="cov8" title="1">if allowedOrigin != "" </span><span class="cov8" title="1">{
                        w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
                        w.Header().Add("Vary", "Origin")
                        w.Header().Set("Access-Control-Allow-Methods", "GET,POST,DELETE,OPTIONS")
                        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                }</span>
                <span class="cov8" title="1">if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func (s *Server) withAuth(next http.Handler) http.Handler <span class="cov8" title="1">{
        if s == nil || !s.apiConfig.AuthEnabled </span><span class="cov8" title="1">{
                return next
        }</span>
        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov8" title="1">auth := strings.TrimSpace(r.Header.Get("Authorization"))
                if auth == "" </span><span class="cov8" title="1">{
                        s.writeError(w, apiErrorUnauthorized("missing authorization header"))
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

type responseRecorder struct {
        http.ResponseWriter
        status int
        bytes  int
}

func (r *responseRecorder) WriteHeader(status int) <span class="cov8" title="1">{
        r.status = status
        r.ResponseWriter.WriteHeader(status)
}</span>

func (r *responseRecorder) Write(data []byte) (int, error) <span class="cov8" title="1">{
        if r.status == 0 </span><span class="cov0" title="0">{
                r.status = http.StatusOK
        }</span>
        <span class="cov8" title="1">n, err := r.ResponseWriter.Write(data)
        r.bytes += n
        return n, err</span>
}

func (r *responseRecorder) Flush() <span class="cov8" title="1">{
        if flusher, ok := r.ResponseWriter.(http.Flusher); ok </span><span class="cov8" title="1">{
                flusher.Flush()
        }</span>
}

func originAllowed(origin string, allowed []string) bool <span class="cov8" title="1">{
        for _, candidate := range allowed </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(candidate)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if trimmed == "*" || trimmed == origin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func containsWildcard(allowed []string) bool <span class="cov8" title="1">{
        for _, candidate := range allowed </span><span class="cov8" title="1">{
                if strings.TrimSpace(candidate) == "*" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import "net/http"

func (s *Server) routes() http.Handler <span class="cov8" title="1">{
        mux := http.NewServeMux()
        mux.Handle("/api/v1/health", s.wrap(s.handleHealth))
        mux.Handle("/api/v1/version", s.wrap(s.handleVersion))

        mux.Handle("/api/v1/runs/stream/all", s.wrap(s.handleAllRunsStream))

        mux.Handle("/api/v1/tasks", s.wrap(s.handleTasks))
        mux.Handle("/api/v1/tasks/", s.wrap(s.handleTaskByID))

        mux.Handle("/api/v1/runs", s.wrap(s.handleRuns))
        mux.Handle("/api/v1/runs/", s.wrap(s.handleRunByID))

        mux.Handle("/api/v1/messages", s.wrap(s.handleMessages))
        mux.Handle("/api/v1/messages/stream", s.wrap(s.handleMessageStream))

        handler := http.Handler(mux)
        handler = s.withAuth(handler)
        handler = s.withCORS(handler)
        handler = s.withLogging(handler)
        return handler
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package api provides the REST API server for Conductor Loop.
package api

import (
        "context"
        "log"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/config"
        "github.com/pkg/errors"
)

// Options configures the REST API server.
type Options struct {
        RootDir          string
        ConfigPath       string
        APIConfig        config.APIConfig
        Version          string
        Logger           *log.Logger
        DisableTaskStart bool
        Now              func() time.Time
}

// Server serves REST API endpoints for tasks and runs.
type Server struct {
        apiConfig  config.APIConfig
        rootDir    string
        configPath string
        version    string
        logger     *log.Logger
        now        func() time.Time
        startTasks bool
        handler    http.Handler
        server     *http.Server

        sseOnce        sync.Once
        sseManagerInst *StreamManager
        sseErr         error
}

// NewServer constructs a REST API server with defaults applied.
func NewServer(opts Options) (*Server, error) <span class="cov8" title="1">{
        rootDir, err := resolveRootDir(opts.RootDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cfg := opts.APIConfig
        if strings.TrimSpace(cfg.Host) == "" </span><span class="cov8" title="1">{
                cfg.Host = "0.0.0.0"
        }</span>
        <span class="cov8" title="1">if cfg.Port == 0 </span><span class="cov8" title="1">{
                cfg.Port = 8080
        }</span>

        <span class="cov8" title="1">logger := opts.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = log.New(os.Stdout, "api ", log.LstdFlags)
        }</span>

        <span class="cov8" title="1">now := opts.Now
        if now == nil </span><span class="cov8" title="1">{
                now = time.Now
        }</span>

        <span class="cov8" title="1">version := strings.TrimSpace(opts.Version)
        if version == "" </span><span class="cov8" title="1">{
                version = "dev"
        }</span>

        <span class="cov8" title="1">s := &amp;Server{
                apiConfig:  cfg,
                rootDir:    rootDir,
                configPath: strings.TrimSpace(opts.ConfigPath),
                version:    version,
                logger:     logger,
                now:        now,
                startTasks: !opts.DisableTaskStart,
        }
        s.handler = s.routes()
        return s, nil</span>
}

// Handler returns the http.Handler for the server.
func (s *Server) Handler() http.Handler <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.handler</span>
}

// ListenAndServe starts the HTTP server.
func (s *Server) ListenAndServe() error <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return errors.New("server is nil")
        }</span>
        <span class="cov8" title="1">if s.server == nil </span><span class="cov8" title="1">{
                addr := net.JoinHostPort(s.apiConfig.Host, intToString(s.apiConfig.Port))
                s.server = &amp;http.Server{
                        Addr:    addr,
                        Handler: s.handler,
                }
        }</span>
        <span class="cov8" title="1">return s.server.ListenAndServe()</span>
}

// Shutdown gracefully stops the HTTP server.
func (s *Server) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        if s == nil || s.server == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.server.Shutdown(ctx)</span>
}

func resolveRootDir(root string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(root)
        if trimmed == "" </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "resolve home dir")
                }</span>
                <span class="cov8" title="1">trimmed = filepath.Join(home, "run-agent")</span>
        }
        <span class="cov8" title="1">abs, err := filepath.Abs(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "resolve root dir")
        }</span>
        <span class="cov8" title="1">return abs, nil</span>
}

func intToString(value int) string <span class="cov8" title="1">{
        return strconv.Itoa(value)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "bufio"
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/messagebus"
        "github.com/jonnyzzz/conductor-loop/internal/storage"
        "github.com/pkg/errors"
)

const (
        defaultPollInterval      = 100 * time.Millisecond
        defaultDiscoveryInterval = time.Second
        defaultHeartbeatInterval = 30 * time.Second
        defaultMaxClientsPerRun  = 10
)

var ErrMaxClientsReached = stderrors.New("max clients reached for run")

// SSEConfig configures log streaming behavior.
type SSEConfig struct {
        PollInterval      time.Duration
        DiscoveryInterval time.Duration
        HeartbeatInterval time.Duration
        MaxClientsPerRun  int
}

func (c SSEConfig) withDefaults() SSEConfig <span class="cov8" title="1">{
        if c.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                c.PollInterval = defaultPollInterval
        }</span>
        <span class="cov8" title="1">if c.DiscoveryInterval &lt;= 0 </span><span class="cov8" title="1">{
                c.DiscoveryInterval = defaultDiscoveryInterval
        }</span>
        <span class="cov8" title="1">if c.HeartbeatInterval &lt;= 0 </span><span class="cov8" title="1">{
                c.HeartbeatInterval = defaultHeartbeatInterval
        }</span>
        <span class="cov8" title="1">if c.MaxClientsPerRun &lt;= 0 </span><span class="cov8" title="1">{
                c.MaxClientsPerRun = defaultMaxClientsPerRun
        }</span>
        <span class="cov8" title="1">return c</span>
}

func (s *Server) handleAllRunsStream(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov0" title="0">return s.streamAllRuns(w, r)</span>
}

func (s *Server) handleMessageStream(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                return apiErrorMethodNotAllowed()
        }</span>
        <span class="cov0" title="0">return s.streamMessages(w, r)</span>
}

func (s *Server) sseConfig() SSEConfig <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return SSEConfig{}.withDefaults()
        }</span>
        <span class="cov8" title="1">cfg := SSEConfig{
                PollInterval:      time.Duration(s.apiConfig.SSE.PollIntervalMs) * time.Millisecond,
                DiscoveryInterval: time.Duration(s.apiConfig.SSE.DiscoveryIntervalMs) * time.Millisecond,
                HeartbeatInterval: time.Duration(s.apiConfig.SSE.HeartbeatIntervalS) * time.Second,
                MaxClientsPerRun:  s.apiConfig.SSE.MaxClientsPerRun,
        }
        return cfg.withDefaults()</span>
}

func (s *Server) sseManager() (*StreamManager, error) <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return nil, errors.New("server is nil")
        }</span>
        <span class="cov8" title="1">s.sseOnce.Do(func() </span><span class="cov8" title="1">{
                s.sseManagerInst, s.sseErr = NewStreamManager(s.rootDir, s.sseConfig())
        }</span>)
        <span class="cov8" title="1">return s.sseManagerInst, s.sseErr</span>
}

func (s *Server) streamRun(w http.ResponseWriter, r *http.Request, runID string) *apiError <span class="cov8" title="1">{
        writer, err := newSSEWriter(w)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorBadRequest("sse not supported")
        }</span>
        <span class="cov8" title="1">manager, err := s.sseManager()
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("init sse manager", err)
        }</span>
        <span class="cov8" title="1">cfg := s.sseConfig()
        cursor := parseCursor(r.Header.Get("Last-Event-ID"))
        sub, err := manager.SubscribeRun(runID, cursor)
        if err != nil </span><span class="cov0" title="0">{
                if stderrors.Is(err, ErrMaxClientsReached) </span><span class="cov0" title="0">{
                        return &amp;apiError{Status: http.StatusTooManyRequests, Code: "TOO_MANY_REQUESTS", Message: err.Error()}
                }</span>
                <span class="cov0" title="0">return apiErrorNotFound("run not found")</span>
        }
        <span class="cov8" title="1">defer sub.Close()

        ctx := r.Context()
        heartbeat := time.NewTicker(cfg.HeartbeatInterval)
        defer heartbeat.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil</span>
                case &lt;-heartbeat.C:<span class="cov0" title="0">
                        _ = writer.Send(SSEEvent{Event: "heartbeat", Data: "{}"})</span>
                case ev, ok := &lt;-sub.Events():<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if err := writer.Send(ev); err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

func (s *Server) streamAllRuns(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        writer, err := newSSEWriter(w)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorBadRequest("sse not supported")
        }</span>
        <span class="cov8" title="1">manager, err := s.sseManager()
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("init sse manager", err)
        }</span>
        <span class="cov8" title="1">cfg := s.sseConfig()
        ctx := r.Context()
        fan := newFanIn(ctx)
        defer fan.Close()

        subsMu := &amp;sync.Mutex{}
        subs := make(map[string]*Subscription)
        addSub := func(runID string, sub *Subscription) </span><span class="cov8" title="1">{
                subsMu.Lock()
                defer subsMu.Unlock()
                subs[runID] = sub
                fan.Add(sub)
        }</span>
        <span class="cov8" title="1">closeSubs := func() </span><span class="cov8" title="1">{
                subsMu.Lock()
                defer subsMu.Unlock()
                for _, sub := range subs </span><span class="cov8" title="1">{
                        sub.Close()
                }</span>
        }
        <span class="cov8" title="1">defer closeSubs()

        runs, err := listRunIDs(s.rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("list runs", err)
        }</span>
        <span class="cov8" title="1">for _, runID := range runs </span><span class="cov8" title="1">{
                sub, err := manager.SubscribeRun(runID, Cursor{})
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">addSub(runID, sub)</span>
        }

        <span class="cov8" title="1">discovery, err := NewRunDiscovery(s.rootDir, cfg.DiscoveryInterval)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("init discovery", err)
        }</span>
        <span class="cov8" title="1">discoveryCtx, cancelDiscovery := context.WithCancel(ctx)
        defer cancelDiscovery()
        go discovery.Poll(discoveryCtx, cfg.DiscoveryInterval)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-discoveryCtx.Done():<span class="cov8" title="1">
                                return</span>
                        case runID := &lt;-discovery.NewRuns():<span class="cov8" title="1">
                                subsMu.Lock()
                                _, exists := subs[runID]
                                subsMu.Unlock()
                                if exists </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">sub, err := manager.SubscribeRun(runID, Cursor{})
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">addSub(runID, sub)</span>
                        }
                }
        }()

        <span class="cov8" title="1">heartbeat := time.NewTicker(cfg.HeartbeatInterval)
        defer heartbeat.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil</span>
                case &lt;-heartbeat.C:<span class="cov0" title="0">
                        _ = writer.Send(SSEEvent{Event: "heartbeat", Data: "{}"})</span>
                case ev, ok := &lt;-fan.Events():<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if err := writer.Send(ev); err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

func (s *Server) streamMessages(w http.ResponseWriter, r *http.Request) *apiError <span class="cov8" title="1">{
        writer, err := newSSEWriter(w)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorBadRequest("sse not supported")
        }</span>
        <span class="cov8" title="1">ctx := r.Context()
        projectID := strings.TrimSpace(r.URL.Query().Get("project_id"))
        if projectID == "" </span><span class="cov8" title="1">{
                return apiErrorBadRequest("project_id is required")
        }</span>
        <span class="cov8" title="1">taskID := strings.TrimSpace(r.URL.Query().Get("task_id"))
        busPath := filepath.Join(s.rootDir, projectID, "PROJECT-MESSAGE-BUS.md")
        if taskID != "" </span><span class="cov0" title="0">{
                busPath = filepath.Join(s.rootDir, projectID, taskID, "TASK-MESSAGE-BUS.md")
        }</span>
        <span class="cov8" title="1">bus, err := messagebus.NewMessageBus(busPath)
        if err != nil </span><span class="cov0" title="0">{
                return apiErrorInternal("open message bus", err)
        }</span>
        <span class="cov8" title="1">cfg := s.sseConfig()
        lastID := strings.TrimSpace(r.Header.Get("Last-Event-ID"))

        pollTicker := time.NewTicker(cfg.PollInterval)
        defer pollTicker.Stop()
        heartbeat := time.NewTicker(cfg.HeartbeatInterval)
        defer heartbeat.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil</span>
                case &lt;-heartbeat.C:<span class="cov0" title="0">
                        _ = writer.Send(SSEEvent{Event: "heartbeat", Data: "{}"})</span>
                case &lt;-pollTicker.C:<span class="cov8" title="1">
                        messages, err := bus.ReadMessages(lastID)
                        if err != nil </span><span class="cov0" title="0">{
                                if stderrors.Is(err, messagebus.ErrSinceIDNotFound) </span><span class="cov0" title="0">{
                                        lastID = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">for _, msg := range messages </span><span class="cov8" title="1">{
                                if msg == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">ts := msg.Timestamp
                                if ts.IsZero() </span><span class="cov0" title="0">{
                                        ts = time.Now().UTC()
                                }</span>
                                <span class="cov8" title="1">payload := messagePayload{
                                        MsgID:     msg.MsgID,
                                        Content:   msg.Body,
                                        Timestamp: ts.Format(time.RFC3339Nano),
                                }
                                data, err := json.Marshal(payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">ev := SSEEvent{
                                        Event: "message",
                                        Data:  string(data),
                                }
                                if err := writer.Send(ev); err != nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">lastID = msg.MsgID</span>
                        }
                }
        }
}

// SSEEvent represents a single Server-Sent Event.
type SSEEvent struct {
        ID    string
        Event string
        Data  string
}

type sseWriter struct {
        w       http.ResponseWriter
        flusher http.Flusher
}

func newSSEWriter(w http.ResponseWriter) (*sseWriter, error) <span class="cov8" title="1">{
        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("response writer does not support flushing")
        }</span>
        <span class="cov8" title="1">header := w.Header()
        header.Set("Content-Type", "text/event-stream")
        header.Set("Cache-Control", "no-cache")
        header.Set("Connection", "keep-alive")
        header.Set("X-Accel-Buffering", "no")
        return &amp;sseWriter{w: w, flusher: flusher}, nil</span>
}

func (s *sseWriter) Send(event SSEEvent) error <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return errors.New("sse writer is nil")
        }</span>
        <span class="cov8" title="1">if event.ID != "" </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(s.w, "id: %s\n", event.ID); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write sse id")
                }</span>
        }
        <span class="cov8" title="1">if event.Event != "" </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(s.w, "event: %s\n", event.Event); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write sse event")
                }</span>
        }
        <span class="cov8" title="1">data := event.Data
        if data == "" </span><span class="cov0" title="0">{
                data = "{}"
        }</span>
        <span class="cov8" title="1">lines := strings.Split(data, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(s.w, "data: %s\n", line); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write sse data")
                }</span>
        }
        <span class="cov8" title="1">if _, err := fmt.Fprint(s.w, "\n"); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write sse terminator")
        }</span>
        <span class="cov8" title="1">s.flusher.Flush()
        return nil</span>
}

type logPayload struct {
        RunID     string `json:"run_id"`
        Stream    string `json:"stream,omitempty"`
        Line      string `json:"line"`
        Timestamp string `json:"timestamp"`
}

type statusPayload struct {
        RunID    string `json:"run_id"`
        Status   string `json:"status"`
        ExitCode int    `json:"exit_code"`
}

type messagePayload struct {
        MsgID     string `json:"msg_id"`
        Content   string `json:"content"`
        Timestamp string `json:"timestamp"`
}

// Cursor tracks last-seen stdout/stderr line counts.
type Cursor struct {
        Stdout int64
        Stderr int64
}

func (c Cursor) isZero() bool <span class="cov8" title="1">{
        return c.Stdout == 0 &amp;&amp; c.Stderr == 0
}</span>

func parseCursor(raw string) Cursor <span class="cov8" title="1">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov8" title="1">{
                return Cursor{}
        }</span>
        <span class="cov8" title="1">if n, err := strconv.ParseInt(raw, 10, 64); err == nil </span><span class="cov8" title="1">{
                return Cursor{Stdout: n, Stderr: n}
        }</span>
        <span class="cov8" title="1">var cursor Cursor
        parts := strings.FieldsFunc(raw, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ';' || r == ',' || r == '|'
        }</span>)
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">key, val, ok := strings.Cut(part, "=")
                if !ok </span><span class="cov0" title="0">{
                        key, val, ok = strings.Cut(part, ":")
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">key = strings.ToLower(strings.TrimSpace(key))
                val = strings.TrimSpace(val)
                num, err := strconv.ParseInt(val, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "s", "stdout", "out":<span class="cov8" title="1">
                        cursor.Stdout = num</span>
                case "e", "stderr", "err":<span class="cov8" title="1">
                        cursor.Stderr = num</span>
                }
        }
        <span class="cov8" title="1">return cursor</span>
}

func formatCursor(c Cursor) string <span class="cov8" title="1">{
        return fmt.Sprintf("s=%d;e=%d", c.Stdout, c.Stderr)
}</span>

type subscriber struct {
        events  chan SSEEvent
        paused  bool
        pending []SSEEvent
        closed  bool
        mu      sync.Mutex
}

func newSubscriber(buffer int, paused bool) *subscriber <span class="cov8" title="1">{
        if buffer &lt;= 0 </span><span class="cov0" title="0">{
                buffer = 32
        }</span>
        <span class="cov8" title="1">return &amp;subscriber{
                events: make(chan SSEEvent, buffer),
                paused: paused,
        }</span>
}

func (s *subscriber) enqueue(event SSEEvent) bool <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if s.closed </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if s.paused </span><span class="cov8" title="1">{
                s.pending = append(s.pending, event)
                return true
        }</span>
        <span class="cov8" title="1">select </span>{
        case s.events &lt;- event:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *subscriber) sendDirect(event SSEEvent) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if s.closed </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case s.events &lt;- event:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func (s *subscriber) resume() <span class="cov8" title="1">{
        s.mu.Lock()
        if s.closed </span><span class="cov0" title="0">{
                s.pending = nil
                s.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">s.paused = false
        pending := s.pending
        s.pending = nil
        for _, event := range pending </span><span class="cov8" title="1">{
                select </span>{
                case s.events &lt;- event:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov8" title="1">s.mu.Unlock()</span>
}

func (s *subscriber) close() <span class="cov8" title="1">{
        s.mu.Lock()
        if s.closed </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">s.closed = true
        close(s.events)
        s.mu.Unlock()</span>
}

// Subscription wraps a subscriber channel.
type Subscription struct {
        events &lt;-chan SSEEvent
        close  func()
}

// Events returns the event channel.
func (s *Subscription) Events() &lt;-chan SSEEvent <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.events</span>
}

// Close releases the subscription.
func (s *Subscription) Close() <span class="cov8" title="1">{
        if s == nil || s.close == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.close()</span>
}

// StreamManager manages run tailers and subscribers.
type StreamManager struct {
        rootDir       string
        pollInterval  time.Duration
        maxClientsRun int
        mu            sync.Mutex
        runs          map[string]*runStream
}

// NewStreamManager creates a StreamManager.
func NewStreamManager(rootDir string, cfg SSEConfig) (*StreamManager, error) <span class="cov8" title="1">{
        cleanRoot := filepath.Clean(strings.TrimSpace(rootDir))
        if cleanRoot == "." || cleanRoot == "" </span><span class="cov0" title="0">{
                return nil, errors.New("root directory is empty")
        }</span>
        <span class="cov8" title="1">cfg = cfg.withDefaults()
        return &amp;StreamManager{
                rootDir:       cleanRoot,
                pollInterval:  cfg.PollInterval,
                maxClientsRun: cfg.MaxClientsPerRun,
                runs:          make(map[string]*runStream),
        }, nil</span>
}

// SubscribeRun registers a subscriber for a run.
func (m *StreamManager) SubscribeRun(runID string, cursor Cursor) (*Subscription, error) <span class="cov8" title="1">{
        rs, err := m.ensureRun(runID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sub, snapshot, err := rs.subscribe(cursor)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !cursor.isZero() &amp;&amp; (cursor.Stdout &lt; snapshot.Stdout || cursor.Stderr &lt; snapshot.Stderr) </span><span class="cov0" title="0">{
                go rs.catchUp(sub, cursor, snapshot)
        }</span>
        <span class="cov8" title="1">return &amp;Subscription{
                events: sub.events,
                close: func() </span><span class="cov8" title="1">{
                        m.unsubscribe(runID, sub)
                }</span>,
        }, nil
}

func (m *StreamManager) ensureRun(runID string) (*runStream, error) <span class="cov8" title="1">{
        cleanID := strings.TrimSpace(runID)
        if cleanID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("run id is empty")
        }</span>
        <span class="cov8" title="1">path, err := findRunInfoPath(m.rootDir, cleanID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">runDir := filepath.Dir(path)

        m.mu.Lock()
        defer m.mu.Unlock()
        if existing, ok := m.runs[cleanID]; ok </span><span class="cov8" title="1">{
                return existing, nil
        }</span>
        <span class="cov8" title="1">rs := newRunStream(cleanID, runDir, m.pollInterval, m.maxClientsRun)
        m.runs[cleanID] = rs
        return rs, nil</span>
}

func (m *StreamManager) unsubscribe(runID string, sub *subscriber) <span class="cov8" title="1">{
        m.mu.Lock()
        rs, ok := m.runs[runID]
        m.mu.Unlock()
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">rs.unsubscribe(sub)
        if rs.isEmpty() </span><span class="cov8" title="1">{
                m.mu.Lock()
                delete(m.runs, runID)
                m.mu.Unlock()
        }</span>
}

type runStream struct {
        runID        string
        runDir       string
        pollInterval time.Duration
        maxClients   int

        mu          sync.Mutex
        subscribers map[*subscriber]struct{}
        logCh       chan LogLine
        stopCh      chan struct{}
        started     bool

        stdoutLines int64
        stderrLines int64
        lastStatus  string
        lastExit    int
}

func newRunStream(runID, runDir string, pollInterval time.Duration, maxClients int) *runStream <span class="cov8" title="1">{
        return &amp;runStream{
                runID:        runID,
                runDir:       runDir,
                pollInterval: pollInterval,
                maxClients:   maxClients,
                subscribers:  make(map[*subscriber]struct{}),
                lastExit:     -1,
        }
}</span>

func (rs *runStream) subscribe(cursor Cursor) (*subscriber, Cursor, error) <span class="cov8" title="1">{
        rs.mu.Lock()
        defer rs.mu.Unlock()
        if rs.maxClients &gt; 0 &amp;&amp; len(rs.subscribers) &gt;= rs.maxClients </span><span class="cov8" title="1">{
                return nil, Cursor{}, ErrMaxClientsReached
        }</span>
        <span class="cov8" title="1">if !rs.started </span><span class="cov8" title="1">{
                rs.startLocked()
        }</span>
        <span class="cov8" title="1">snapshot := Cursor{Stdout: rs.stdoutLines, Stderr: rs.stderrLines}
        paused := !cursor.isZero() &amp;&amp; (cursor.Stdout &lt; snapshot.Stdout || cursor.Stderr &lt; snapshot.Stderr)
        sub := newSubscriber(128, paused)
        rs.subscribers[sub] = struct{}{}
        return sub, snapshot, nil</span>
}

func (rs *runStream) unsubscribe(sub *subscriber) <span class="cov8" title="1">{
        rs.mu.Lock()
        defer rs.mu.Unlock()
        delete(rs.subscribers, sub)
        sub.close()
        if len(rs.subscribers) == 0 </span><span class="cov8" title="1">{
                rs.stopLocked()
        }</span>
}

func (rs *runStream) isEmpty() bool <span class="cov8" title="1">{
        rs.mu.Lock()
        defer rs.mu.Unlock()
        return len(rs.subscribers) == 0
}</span>

func (rs *runStream) startLocked() <span class="cov8" title="1">{
        if rs.started </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">rs.logCh = make(chan LogLine, 256)
        rs.stopCh = make(chan struct{})
        rs.started = true

        ctx, cancel := context.WithCancel(context.Background())
        go func() </span><span class="cov8" title="1">{
                &lt;-rs.stopCh
                cancel()
        }</span>()

        <span class="cov8" title="1">stdoutPath := filepath.Join(rs.runDir, "agent-stdout.txt")
        stderrPath := filepath.Join(rs.runDir, "agent-stderr.txt")
        if count, err := countLines(stdoutPath); err == nil </span><span class="cov8" title="1">{
                rs.stdoutLines = count
        }</span>
        <span class="cov8" title="1">if count, err := countLines(stderrPath); err == nil </span><span class="cov8" title="1">{
                rs.stderrLines = count
        }</span>
        <span class="cov8" title="1">stdoutTailer, _ := NewTailer(stdoutPath, rs.runID, "stdout", rs.pollInterval, -1, rs.logCh)
        stderrTailer, _ := NewTailer(stderrPath, rs.runID, "stderr", rs.pollInterval, -1, rs.logCh)
        if stdoutTailer != nil </span><span class="cov8" title="1">{
                stdoutTailer.Start(ctx)
        }</span>
        <span class="cov8" title="1">if stderrTailer != nil </span><span class="cov8" title="1">{
                stderrTailer.Start(ctx)
        }</span>
        <span class="cov8" title="1">go rs.loop(ctx, stdoutTailer, stderrTailer)</span>
}

func (rs *runStream) stopLocked() <span class="cov8" title="1">{
        if !rs.started </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">close(rs.stopCh)
        rs.started = false</span>
}

func (rs *runStream) loop(ctx context.Context, stdoutTailer, stderrTailer *Tailer) <span class="cov8" title="1">{
        statusTicker := time.NewTicker(rs.pollInterval)
        defer statusTicker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        if stdoutTailer != nil </span><span class="cov8" title="1">{
                                stdoutTailer.Stop()
                        }</span>
                        <span class="cov8" title="1">if stderrTailer != nil </span><span class="cov8" title="1">{
                                stderrTailer.Stop()
                        }</span>
                        <span class="cov8" title="1">return</span>
                case line := &lt;-rs.logCh:<span class="cov8" title="1">
                        rs.handleLogLine(line)</span>
                case &lt;-statusTicker.C:<span class="cov8" title="1">
                        rs.checkStatus()</span>
                }
        }
}

func (rs *runStream) handleLogLine(line LogLine) <span class="cov8" title="1">{
        var cursor Cursor
        rs.mu.Lock()
        switch line.Stream </span>{
        case "stdout":<span class="cov8" title="1">
                rs.stdoutLines++</span>
        case "stderr":<span class="cov0" title="0">
                rs.stderrLines++</span>
        }
        <span class="cov8" title="1">cursor = Cursor{Stdout: rs.stdoutLines, Stderr: rs.stderrLines}
        subs := make([]*subscriber, 0, len(rs.subscribers))
        for sub := range rs.subscribers </span><span class="cov8" title="1">{
                subs = append(subs, sub)
        }</span>
        <span class="cov8" title="1">rs.mu.Unlock()

        payload := logPayload{
                RunID:     line.RunID,
                Stream:    line.Stream,
                Line:      line.Line,
                Timestamp: line.Timestamp.Format(time.RFC3339Nano),
        }
        data, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">event := SSEEvent{
                ID:    formatCursor(cursor),
                Event: "log",
                Data:  string(data),
        }
        for _, sub := range subs </span><span class="cov8" title="1">{
                if !sub.enqueue(event) </span><span class="cov0" title="0">{
                        rs.unsubscribe(sub)
                }</span>
        }
}

func (rs *runStream) checkStatus() <span class="cov8" title="1">{
        path := filepath.Join(rs.runDir, "run-info.yaml")
        info, err := storage.ReadRunInfo(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">status := strings.TrimSpace(info.Status)
        exitCode := info.ExitCode
        shouldReport := false
        if exitCode &gt;= 0 </span><span class="cov8" title="1">{
                if status == "" </span><span class="cov0" title="0">{
                        status = storage.StatusCompleted
                }</span>
                <span class="cov8" title="1">shouldReport = true</span>
        } else<span class="cov0" title="0"> if status != "" &amp;&amp; status != storage.StatusRunning </span><span class="cov0" title="0">{
                shouldReport = true
        }</span>
        <span class="cov8" title="1">rs.mu.Lock()
        changed := shouldReport &amp;&amp; (status != rs.lastStatus || exitCode != rs.lastExit)
        if changed </span><span class="cov8" title="1">{
                rs.lastStatus = status
                rs.lastExit = exitCode
        }</span>
        <span class="cov8" title="1">subs := make([]*subscriber, 0, len(rs.subscribers))
        for sub := range rs.subscribers </span><span class="cov8" title="1">{
                subs = append(subs, sub)
        }</span>
        <span class="cov8" title="1">rs.mu.Unlock()
        if !changed </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">payload := statusPayload{
                RunID:    rs.runID,
                Status:   status,
                ExitCode: exitCode,
        }
        data, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">event := SSEEvent{
                Event: "status",
                Data:  string(data),
        }
        for _, sub := range subs </span><span class="cov8" title="1">{
                if !sub.enqueue(event) </span><span class="cov0" title="0">{
                        rs.unsubscribe(sub)
                }</span>
        }
}

func (rs *runStream) catchUp(sub *subscriber, cursor, snapshot Cursor) <span class="cov8" title="1">{
        stdoutPath := filepath.Join(rs.runDir, "agent-stdout.txt")
        stderrPath := filepath.Join(rs.runDir, "agent-stderr.txt")
        current := cursor
        if snapshot.Stdout &gt; cursor.Stdout </span><span class="cov8" title="1">{
                lines, err := readLinesRange(stdoutPath, cursor.Stdout, snapshot.Stdout)
                if err == nil </span><span class="cov8" title="1">{
                        for _, line := range lines </span><span class="cov8" title="1">{
                                current.Stdout++
                                rs.sendCatchup(sub, current, "stdout", line)
                        }</span>
                }
        }
        <span class="cov8" title="1">if snapshot.Stderr &gt; cursor.Stderr </span><span class="cov8" title="1">{
                lines, err := readLinesRange(stderrPath, cursor.Stderr, snapshot.Stderr)
                if err == nil </span><span class="cov8" title="1">{
                        for _, line := range lines </span><span class="cov8" title="1">{
                                current.Stderr++
                                rs.sendCatchup(sub, current, "stderr", line)
                        }</span>
                }
        }
        <span class="cov8" title="1">sub.resume()</span>
}

func (rs *runStream) sendCatchup(sub *subscriber, cursor Cursor, stream, line string) <span class="cov8" title="1">{
        payload := logPayload{
                RunID:     rs.runID,
                Stream:    stream,
                Line:      line,
                Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
        }
        data, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">event := SSEEvent{
                ID:    formatCursor(cursor),
                Event: "log",
                Data:  string(data),
        }
        sub.sendDirect(event)</span>
}

func readLinesRange(path string, startLine, endLine int64) ([]string, error) <span class="cov8" title="1">{
        if endLine &lt;= startLine </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "open log file")</span>
        }
        <span class="cov8" title="1">defer file.Close()

        reader := bufio.NewReader(file)
        var (
                lines []string
                count int64
        )
        for count &lt; endLine </span><span class="cov8" title="1">{
                part, err := reader.ReadString('\n')
                if part != "" </span><span class="cov8" title="1">{
                        count++
                        if count &gt; startLine </span><span class="cov8" title="1">{
                                line := strings.TrimSuffix(part, "\n")
                                line = strings.TrimSuffix(line, "\r")
                                lines = append(lines, line)
                        }</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "read log file")
                }</span>
        }
        <span class="cov8" title="1">return lines, nil</span>
}

func countLines(path string) (int64, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, errors.Wrap(err, "open log file")</span>
        }
        <span class="cov8" title="1">defer file.Close()

        reader := bufio.NewReader(file)
        var count int64
        for </span><span class="cov8" title="1">{
                part, err := reader.ReadString('\n')
                if part != "" </span><span class="cov8" title="1">{
                        count++
                }</span>
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return 0, errors.Wrap(err, "read log file")
                }</span>
        }
        <span class="cov8" title="1">return count, nil</span>
}

type fanIn struct {
        ctx    context.Context
        events chan SSEEvent
        wg     sync.WaitGroup
}

func newFanIn(ctx context.Context) *fanIn <span class="cov8" title="1">{
        return &amp;fanIn{
                ctx:    ctx,
                events: make(chan SSEEvent, 256),
        }
}</span>

func (f *fanIn) Add(sub *Subscription) <span class="cov8" title="1">{
        if f == nil || sub == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">f.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer f.wg.Done()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-f.ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case ev, ok := &lt;-sub.Events():<span class="cov8" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">select </span>{
                                case f.events &lt;- ev:<span class="cov8" title="1"></span>
                                case &lt;-f.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()
}

func (f *fanIn) Events() &lt;-chan SSEEvent <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return f.events</span>
}

func (f *fanIn) Close() <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">f.wg.Wait()
        close(f.events)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "bufio"
        "context"
        "io"
        "os"
        "strings"
        "time"

        "github.com/pkg/errors"
)

// LogLine represents a tailed log line.
type LogLine struct {
        RunID     string
        Stream    string
        Line      string
        Timestamp time.Time
}

// Tailer polls a log file and emits new lines.
type Tailer struct {
        filePath     string
        runID        string
        stream       string
        pollInterval time.Duration
        offset       int64
        pending      string
        events       chan&lt;- LogLine
        done         chan struct{}
        ticker       *time.Ticker
}

// NewTailer creates a Tailer starting after the provided line number.
func NewTailer(filePath, runID, stream string, pollInterval time.Duration, startLine int64, events chan&lt;- LogLine) (*Tailer, error) <span class="cov8" title="1">{
        cleanPath := strings.TrimSpace(filePath)
        if cleanPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("file path is empty")
        }</span>
        <span class="cov8" title="1">if pollInterval &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("poll interval must be positive")
        }</span>
        <span class="cov8" title="1">offset, err := offsetForLine(cleanPath, startLine)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "compute start offset")
        }</span>
        <span class="cov8" title="1">return &amp;Tailer{
                filePath:     cleanPath,
                runID:        strings.TrimSpace(runID),
                stream:       strings.TrimSpace(stream),
                pollInterval: pollInterval,
                offset:       offset,
                events:       events,
                done:         make(chan struct{}),
        }, nil</span>
}

// Start begins polling in a goroutine.
func (t *Tailer) Start(ctx context.Context) <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">t.ticker = time.NewTicker(t.pollInterval)
        go func() </span><span class="cov8" title="1">{
                defer t.ticker.Stop()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case &lt;-t.done:<span class="cov8" title="1">
                                return</span>
                        case &lt;-t.ticker.C:<span class="cov8" title="1">
                                _ = t.poll()</span>
                        }
                }
        }()
}

// Stop stops polling.
func (t *Tailer) Stop() <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">select </span>{
        case &lt;-t.done:<span class="cov8" title="1">
                return</span>
        default:<span class="cov8" title="1">
                close(t.done)</span>
        }
}

func (t *Tailer) poll() error <span class="cov8" title="1">{
        file, err := os.Open(t.filePath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "open log file")</span>
        }
        <span class="cov8" title="1">defer file.Close()

        info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "stat log file")
        }</span>
        <span class="cov8" title="1">if info.Size() &lt; t.offset </span><span class="cov0" title="0">{
                t.offset = 0
                t.pending = ""
        }</span>
        <span class="cov8" title="1">if _, err := file.Seek(t.offset, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "seek log file")
        }</span>

        <span class="cov8" title="1">reader := bufio.NewReader(file)
        for </span><span class="cov8" title="1">{
                part, err := reader.ReadString('\n')
                if part != "" </span><span class="cov8" title="1">{
                        t.offset += int64(len(part))
                        if strings.HasSuffix(part, "\n") </span><span class="cov8" title="1">{
                                line := t.pending + strings.TrimSuffix(part, "\n")
                                t.pending = ""
                                line = strings.TrimSuffix(line, "\r")
                                t.emit(line)
                        }</span> else<span class="cov0" title="0"> {
                                t.pending += part
                        }</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "read log file")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *Tailer) emit(line string) <span class="cov8" title="1">{
        if t.events == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">event := LogLine{
                RunID:     t.runID,
                Stream:    t.stream,
                Line:      line,
                Timestamp: time.Now().UTC(),
        }
        select </span>{
        case t.events &lt;- event:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func offsetForLine(path string, line int64) (int64, error) <span class="cov8" title="1">{
        if line &lt; 0 </span><span class="cov8" title="1">{
                return offsetForEnd(path)
        }</span>
        <span class="cov8" title="1">if line == 0 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, errors.Wrap(err, "open log file")</span>
        }
        <span class="cov8" title="1">defer file.Close()

        reader := bufio.NewReader(file)
        var (
                offset int64
                count  int64
        )
        for count &lt; line </span><span class="cov8" title="1">{
                part, err := reader.ReadString('\n')
                if part != "" </span><span class="cov8" title="1">{
                        offset += int64(len(part))
                        count++
                }</span>
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return 0, errors.Wrap(err, "read log file")
                }</span>
        }
        <span class="cov8" title="1">return offset, nil</span>
}

func offsetForEnd(path string) (int64, error) <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, errors.Wrap(err, "stat log file")</span>
        }
        <span class="cov8" title="1">return info.Size(), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import "strings"

// APIConfig defines the REST API configuration settings.
type APIConfig struct {
        Host        string    `yaml:"host"`
        Port        int       `yaml:"port"`
        CORSOrigins []string  `yaml:"cors_origins"`
        AuthEnabled bool      `yaml:"auth_enabled"`
        SSE         SSEConfig `yaml:"sse"`
}

// SSEConfig defines server-sent events configuration.
type SSEConfig struct {
        PollIntervalMs      int `yaml:"poll_interval_ms"`
        DiscoveryIntervalMs int `yaml:"discovery_interval_ms"`
        HeartbeatIntervalS  int `yaml:"heartbeat_interval_s"`
        MaxClientsPerRun    int `yaml:"max_clients_per_run"`
}

func applyAPIDefaults(cfg *Config) <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(cfg.API.Host) == "" </span><span class="cov8" title="1">{
                cfg.API.Host = "0.0.0.0"
        }</span>
        <span class="cov8" title="1">if cfg.API.Port == 0 </span><span class="cov8" title="1">{
                cfg.API.Port = 8080
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.PollIntervalMs == 0 </span><span class="cov8" title="1">{
                cfg.API.SSE.PollIntervalMs = 100
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.DiscoveryIntervalMs == 0 </span><span class="cov8" title="1">{
                cfg.API.SSE.DiscoveryIntervalMs = 1000
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.HeartbeatIntervalS == 0 </span><span class="cov8" title="1">{
                cfg.API.SSE.HeartbeatIntervalS = 30
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.MaxClientsPerRun == 0 </span><span class="cov8" title="1">{
                cfg.API.SSE.MaxClientsPerRun = 10
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package config provides YAML configuration loading for conductor loop.
package config

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config defines the YAML configuration structure.
type Config struct {
        Agents   map[string]AgentConfig `yaml:"agents"`
        Defaults DefaultConfig          `yaml:"defaults"`
        API      APIConfig              `yaml:"api"`
        Storage  StorageConfig          `yaml:"storage"`
}

// AgentConfig describes a single agent backend configuration.
type AgentConfig struct {
        Type      string `yaml:"type"` // claude, codex, gemini, perplexity, xai
        Token     string `yaml:"token,omitempty"`
        TokenFile string `yaml:"token_file,omitempty"`
        BaseURL   string `yaml:"base_url,omitempty"`
        Model     string `yaml:"model,omitempty"`

        tokenFromFile bool `yaml:"-"`
}

// DefaultConfig defines defaults used by the runner.
type DefaultConfig struct {
        Agent   string `yaml:"agent"`
        Timeout int    `yaml:"timeout"`
}

// StorageConfig defines storage-related settings.
type StorageConfig struct {
        RunsDir string `yaml:"runs_dir"`
}

// LoadConfig loads and validates configuration from a YAML file.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config path is empty")
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read config: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse config: %w", err)
        }</span>

        <span class="cov8" title="1">if cfg.Agents == nil </span><span class="cov0" title="0">{
                cfg.Agents = make(map[string]AgentConfig)
        }</span>

        <span class="cov8" title="1">applyAgentDefaults(&amp;cfg)
        applyAPIDefaults(&amp;cfg)
        applyTokenEnvOverrides(&amp;cfg)

        baseDir := filepath.Dir(path)
        if err := resolveTokenFilePaths(&amp;cfg, baseDir); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := resolveStoragePaths(&amp;cfg, baseDir); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := ValidateConfig(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := resolveTokens(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// LoadConfigForServer loads configuration without validating agent tokens.
// This is intended for API server startup where agent execution may be disabled.
func LoadConfigForServer(path string) (*Config, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config path is empty")
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read config: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse config: %w", err)
        }</span>

        <span class="cov8" title="1">if cfg.Agents == nil </span><span class="cov0" title="0">{
                cfg.Agents = make(map[string]AgentConfig)
        }</span>

        <span class="cov8" title="1">applyAgentDefaults(&amp;cfg)
        applyAPIDefaults(&amp;cfg)
        applyTokenEnvOverrides(&amp;cfg)

        baseDir := filepath.Dir(path)
        if err := resolveTokenFilePaths(&amp;cfg, baseDir); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := resolveStoragePaths(&amp;cfg, baseDir); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

func applyAgentDefaults(cfg *Config) <span class="cov8" title="1">{
        for name, agent := range cfg.Agents </span><span class="cov8" title="1">{
                if agent.Type == "" </span><span class="cov0" title="0">{
                        agent.Type = name
                }</span>
                <span class="cov8" title="1">agent.Type = normalizeAgentType(agent.Type)
                cfg.Agents[name] = agent</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import "fmt"

func resolveStoragePaths(cfg *Config, baseDir string) error <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if cfg.Storage.RunsDir == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">resolved, err := resolvePath(baseDir, cfg.Storage.RunsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("resolve storage.runs_dir: %w", err)
        }</span>
        <span class="cov8" title="1">cfg.Storage.RunsDir = resolved
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

func applyTokenEnvOverrides(cfg *Config) <span class="cov8" title="1">{
        for name, agent := range cfg.Agents </span><span class="cov8" title="1">{
                envName := tokenEnvVarName(name)
                if value, ok := os.LookupEnv(envName); ok </span><span class="cov8" title="1">{
                        value = strings.TrimSpace(value)
                        if value != "" </span><span class="cov8" title="1">{
                                agent.Token = value
                                agent.TokenFile = ""
                                agent.tokenFromFile = false
                                cfg.Agents[name] = agent
                        }</span>
                }
        }
}

func tokenEnvVarName(name string) string <span class="cov8" title="1">{
        upper := strings.ToUpper(name)
        var b strings.Builder
        b.Grow(len(upper))
        for _, r := range upper </span><span class="cov8" title="1">{
                if (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') </span><span class="cov8" title="1">{
                        b.WriteRune(r)
                        continue</span>
                }
                <span class="cov8" title="1">b.WriteByte('_')</span>
        }

        <span class="cov8" title="1">return "CONDUCTOR_AGENT_" + b.String() + "_TOKEN"</span>
}

func resolveTokenFilePaths(cfg *Config, baseDir string) error <span class="cov8" title="1">{
        for name, agent := range cfg.Agents </span><span class="cov8" title="1">{
                if agent.TokenFile == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">resolved, err := resolvePath(baseDir, agent.TokenFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("resolve token_file for agent %q: %w", name, err)
                }</span>

                <span class="cov8" title="1">agent.TokenFile = resolved
                cfg.Agents[name] = agent</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func resolvePath(baseDir, target string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(target)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(trimmed, "~") </span><span class="cov8" title="1">{
                resolved, err := expandHome(trimmed)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">trimmed = resolved</span>
        }

        <span class="cov8" title="1">if !filepath.IsAbs(trimmed) </span><span class="cov8" title="1">{
                trimmed = filepath.Join(baseDir, trimmed)
        }</span>

        <span class="cov8" title="1">abs, err := filepath.Abs(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("resolve path %q: %w", trimmed, err)
        }</span>

        <span class="cov8" title="1">return abs, nil</span>
}

func expandHome(path string) (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("resolve home dir: %w", err)
        }</span>

        <span class="cov8" title="1">if path == "~" </span><span class="cov8" title="1">{
                return home, nil
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(path, "~/") </span><span class="cov8" title="1">{
                return filepath.Join(home, path[2:]), nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("unsupported home expansion: %q", path)</span>
}

func resolveTokens(cfg *Config) error <span class="cov8" title="1">{
        for name, agent := range cfg.Agents </span><span class="cov8" title="1">{
                if agent.TokenFile == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">token, err := readTokenFile(agent.TokenFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read token_file for agent %q: %w", name, err)
                }</span>

                <span class="cov8" title="1">agent.Token = token
                agent.tokenFromFile = true
                cfg.Agents[name] = agent</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func readTokenFile(path string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">trimmed := strings.TrimSpace(string(data))
        if trimmed == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("token file is empty: %s", path)
        }</span>

        <span class="cov8" title="1">return trimmed, nil</span>
}

func normalizeAgentType(value string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(value))
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package config

import (
        "fmt"
        "os"
)

var validAgentTypes = map[string]struct{}{
        "claude":     {},
        "codex":      {},
        "gemini":     {},
        "perplexity": {},
        "xai":        {},
}

// ValidateConfig validates the configuration for required fields and constraints.
func ValidateConfig(cfg *Config) error <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("config is nil")
        }</span>

        <span class="cov8" title="1">if len(cfg.Agents) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no agents configured")
        }</span>

        <span class="cov8" title="1">if cfg.Defaults.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("defaults.timeout must be positive")
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.PollIntervalMs &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("api.sse.poll_interval_ms must be non-negative")
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.DiscoveryIntervalMs &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("api.sse.discovery_interval_ms must be non-negative")
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.HeartbeatIntervalS &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("api.sse.heartbeat_interval_s must be non-negative")
        }</span>
        <span class="cov8" title="1">if cfg.API.SSE.MaxClientsPerRun &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("api.sse.max_clients_per_run must be non-negative")
        }</span>

        <span class="cov8" title="1">for name, agent := range cfg.Agents </span><span class="cov8" title="1">{
                if agent.Type == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("agent %q has empty type", name)
                }</span>

                <span class="cov8" title="1">if _, ok := validAgentTypes[agent.Type]; !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("agent %q has invalid type %q", name, agent.Type)
                }</span>

                <span class="cov8" title="1">if agent.Token == "" &amp;&amp; agent.TokenFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("agent %q must set token or token_file", name)
                }</span>

                <span class="cov8" title="1">if agent.Token != "" &amp;&amp; agent.TokenFile != "" &amp;&amp; !agent.tokenFromFile </span><span class="cov0" title="0">{
                        return fmt.Errorf("agent %q cannot set both token and token_file", name)
                }</span>

                <span class="cov8" title="1">if agent.TokenFile != "" </span><span class="cov8" title="1">{
                        if err := validateTokenFile(agent.TokenFile); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("agent %q token_file %q: %w", name, agent.TokenFile, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if cfg.API.Port &lt; 0 || cfg.API.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("api.port must be between 0 and 65535")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateTokenFile(path string) error <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov8" title="1">{
                return fmt.Errorf("not a regular file")
        }</span>

        <span class="cov8" title="1">if _, err := os.ReadFile(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package messagebus

import (
        stderrors "errors"
        "os"
        "time"

        "github.com/pkg/errors"
)

const lockPollInterval = 10 * time.Millisecond

// ErrLockTimeout indicates the lock was not acquired within the timeout.
var ErrLockTimeout = stderrors.New("lock timeout")

// LockExclusive acquires an exclusive lock with the specified timeout.
func LockExclusive(file *os.File, timeout time.Duration) error <span class="cov8" title="1">{
        return flockExclusive(file, timeout)
}</span>

// Unlock releases a previously acquired lock.
func Unlock(file *os.File) error <span class="cov8" title="1">{
        if file == nil </span><span class="cov8" title="1">{
                return errors.New("lock file is nil")
        }</span>
        <span class="cov8" title="1">return unlockFile(file)</span>
}

func flockExclusive(file *os.File, timeout time.Duration) error <span class="cov8" title="1">{
        if file == nil </span><span class="cov0" title="0">{
                return errors.New("lock file is nil")
        }</span>
        <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("lock timeout must be positive")
        }</span>
        <span class="cov8" title="1">deadline := time.Now().Add(timeout)
        for </span><span class="cov8" title="1">{
                locked, err := tryFlockExclusive(file)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "flock")
                }</span>
                <span class="cov8" title="1">if locked </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">if time.Now().After(deadline) </span><span class="cov0" title="0">{
                        return ErrLockTimeout
                }</span>
                <span class="cov0" title="0">time.Sleep(lockPollInterval)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">//go:build !windows

package messagebus

import (
        "os"
        "syscall"
)

func tryFlockExclusive(file *os.File) (bool, error) <span class="cov8" title="1">{
        err := syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if err == syscall.EWOULDBLOCK || err == syscall.EAGAIN </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func unlockFile(file *os.File) error <span class="cov8" title="1">{
        return syscall.Flock(int(file.Fd()), syscall.LOCK_UN)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package messagebus

import (
        "bufio"
        "bytes"
        stderrors "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"
)

const (
        defaultLockTimeout  = 10 * time.Second
        defaultPollInterval = 200 * time.Millisecond
        messageBusFileMode  = 0o644
)

// ErrSinceIDNotFound indicates the requested since ID was not found.
var ErrSinceIDNotFound = stderrors.New("since id not found")

// Message represents a message bus entry.
type Message struct {
        MsgID        string    `yaml:"msg_id"`
        Timestamp    time.Time `yaml:"ts"`
        Type         string    `yaml:"type"`
        ProjectID    string    `yaml:"project_id"`
        TaskID       string    `yaml:"task_id"`
        RunID        string    `yaml:"run_id"`
        ParentMsgIDs []string  `yaml:"parents,omitempty"`
        Attachment   string    `yaml:"attachment_path,omitempty"`
        Body         string    `yaml:"-"`
}

// MessageBus manages append-only message bus files.
type MessageBus struct {
        path         string
        now          func() time.Time
        lockTimeout  time.Duration
        pollInterval time.Duration
}

// Option configures a MessageBus.
type Option func(*MessageBus)

// WithLockTimeout sets the exclusive lock timeout.
func WithLockTimeout(timeout time.Duration) Option <span class="cov8" title="1">{
        return func(bus *MessageBus) </span><span class="cov8" title="1">{
                bus.lockTimeout = timeout
        }</span>
}

// WithPollInterval sets the poll interval for PollForNew.
func WithPollInterval(interval time.Duration) Option <span class="cov8" title="1">{
        return func(bus *MessageBus) </span><span class="cov8" title="1">{
                bus.pollInterval = interval
        }</span>
}

// WithClock sets the clock used for timestamps.
func WithClock(now func() time.Time) Option <span class="cov8" title="1">{
        return func(bus *MessageBus) </span><span class="cov8" title="1">{
                bus.now = now
        }</span>
}

// NewMessageBus creates a MessageBus for the provided path.
func NewMessageBus(path string, opts ...Option) (*MessageBus, error) <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(path))
        if clean == "." || clean == "" </span><span class="cov8" title="1">{
                return nil, errors.New("message bus path is empty")
        }</span>
        <span class="cov8" title="1">bus := &amp;MessageBus{
                path:         clean,
                now:          time.Now,
                lockTimeout:  defaultLockTimeout,
                pollInterval: defaultPollInterval,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if opt != nil </span><span class="cov8" title="1">{
                        opt(bus)
                }</span>
        }
        <span class="cov8" title="1">if bus.now == nil </span><span class="cov8" title="1">{
                return nil, errors.New("clock is nil")
        }</span>
        <span class="cov8" title="1">if bus.lockTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("lock timeout must be positive")
        }</span>
        <span class="cov8" title="1">if bus.pollInterval &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("poll interval must be positive")
        }</span>
        <span class="cov8" title="1">return bus, nil</span>
}

// AppendMessage appends a message to the bus and returns its msg_id.
func (mb *MessageBus) AppendMessage(msg *Message) (string, error) <span class="cov8" title="1">{
        if mb == nil </span><span class="cov8" title="1">{
                return "", errors.New("message bus is nil")
        }</span>
        <span class="cov8" title="1">if msg == nil </span><span class="cov8" title="1">{
                return "", errors.New("message is nil")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msg.Type) == "" </span><span class="cov8" title="1">{
                return "", errors.New("message type is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msg.ProjectID) == "" </span><span class="cov8" title="1">{
                return "", errors.New("project id is empty")
        }</span>

        <span class="cov8" title="1">msg.MsgID = GenerateMessageID()
        if msg.Timestamp.IsZero() </span><span class="cov8" title="1">{
                msg.Timestamp = mb.now().UTC()
        }</span> else<span class="cov0" title="0"> {
                msg.Timestamp = msg.Timestamp.UTC()
        }</span>

        <span class="cov8" title="1">data, err := serializeMessage(msg)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "serialize message")
        }</span>

        <span class="cov8" title="1">if err := validateBusPath(mb.path); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "validate message bus path")
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(mb.path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, messageBusFileMode)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "open message bus")
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := LockExclusive(file, mb.lockTimeout); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("lock message bus: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = Unlock(file)
        }</span>()

        <span class="cov8" title="1">if err := appendEntry(file, data); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "write message")
        }</span>
        <span class="cov8" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "fsync message bus")
        }</span>
        <span class="cov8" title="1">return msg.MsgID, nil</span>
}

// ReadMessages reads messages after sinceID. If sinceID is empty, returns all messages.
func (mb *MessageBus) ReadMessages(sinceID string) ([]*Message, error) <span class="cov8" title="1">{
        if mb == nil </span><span class="cov0" title="0">{
                return nil, errors.New("message bus is nil")
        }</span>
        <span class="cov8" title="1">if err := validateBusPath(mb.path); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "validate message bus path")
        }</span>
        <span class="cov8" title="1">data, err := os.ReadFile(mb.path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return []*Message{}, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "read message bus")</span>
        }
        <span class="cov8" title="1">messages, err := parseMessages(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return filterSince(messages, sinceID)</span>
}

// PollForNew blocks until new messages appear after lastID.
func (mb *MessageBus) PollForNew(lastID string) ([]*Message, error) <span class="cov8" title="1">{
        if mb == nil </span><span class="cov0" title="0">{
                return nil, errors.New("message bus is nil")
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                messages, err := mb.ReadMessages(lastID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(messages) &gt; 0 </span><span class="cov8" title="1">{
                        return messages, nil
                }</span>
                <span class="cov8" title="1">time.Sleep(mb.pollInterval)</span>
        }
}

func appendEntry(file *os.File, data []byte) error <span class="cov8" title="1">{
        if file == nil </span><span class="cov8" title="1">{
                return errors.New("message bus file is nil")
        }</span>
        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov0" title="0">{
                return errors.New("message data is empty")
        }</span>
        <span class="cov8" title="1">info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "stat message bus")
        }</span>
        <span class="cov8" title="1">if info.Size() &gt; 0 </span><span class="cov8" title="1">{
                if _, err := file.Write([]byte("\n")); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "write separator")
                }</span>
        }
        <span class="cov8" title="1">if err := writeAll(file, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeAll(w io.Writer, data []byte) error <span class="cov8" title="1">{
        for len(data) &gt; 0 </span><span class="cov8" title="1">{
                n, err := w.Write(data)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "write message data")
                }</span>
                <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                        return errors.New("short write")
                }</span>
                <span class="cov8" title="1">data = data[n:]</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func serializeMessage(msg *Message) ([]byte, error) <span class="cov8" title="1">{
        if msg == nil </span><span class="cov0" title="0">{
                return nil, errors.New("message is nil")
        }</span>
        <span class="cov8" title="1">header, err := yaml.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "marshal message")
        }</span>
        <span class="cov8" title="1">var buf bytes.Buffer
        buf.WriteString("---\n")
        buf.Write(header)
        if len(header) == 0 || header[len(header)-1] != '\n' </span><span class="cov0" title="0">{
                buf.WriteByte('\n')
        }</span>
        <span class="cov8" title="1">buf.WriteString("---\n")
        if msg.Body != "" </span><span class="cov8" title="1">{
                buf.WriteString(msg.Body)
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(msg.Body, "\n") </span><span class="cov8" title="1">{
                buf.WriteByte('\n')
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

func parseMessages(data []byte) ([]*Message, error) <span class="cov8" title="1">{
        reader := bufio.NewReader(bytes.NewReader(data))
        const (
                stateSeekHeader = iota
                stateHeader
                stateBody
        )
        state := stateSeekHeader
        var headerBuf bytes.Buffer
        var bodyBuf bytes.Buffer
        var current *Message
        messages := make([]*Message, 0)

        for </span><span class="cov8" title="1">{
                line, err := reader.ReadString('\n')
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "read message bus")
                }</span>
                <span class="cov8" title="1">if err == io.EOF &amp;&amp; line == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">trimmed := strings.TrimRight(line, "\r\n")
                switch state </span>{
                case stateSeekHeader:<span class="cov8" title="1">
                        if trimmed == "---" </span><span class="cov8" title="1">{
                                state = stateHeader
                                headerBuf.Reset()
                        }</span>
                case stateHeader:<span class="cov8" title="1">
                        if trimmed == "---" </span><span class="cov8" title="1">{
                                var msg Message
                                if err := yaml.Unmarshal(headerBuf.Bytes(), &amp;msg); err != nil </span><span class="cov0" title="0">{
                                        headerBuf.Reset()
                                        current = nil
                                        state = stateHeader
                                        break</span>
                                }
                                <span class="cov8" title="1">current = &amp;msg
                                bodyBuf.Reset()
                                state = stateBody</span>
                        } else<span class="cov8" title="1"> {
                                headerBuf.WriteString(line)
                        }</span>
                case stateBody:<span class="cov8" title="1">
                        if trimmed == "---" </span><span class="cov8" title="1">{
                                if current != nil </span><span class="cov8" title="1">{
                                        current.Body = finalizeBody(bodyBuf.Bytes())
                                        messages = append(messages, current)
                                }</span>
                                <span class="cov8" title="1">headerBuf.Reset()
                                state = stateHeader</span>
                        } else<span class="cov8" title="1"> {
                                bodyBuf.WriteString(line)
                        }</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if state == stateBody &amp;&amp; current != nil </span><span class="cov8" title="1">{
                bodyBytes := bodyBuf.Bytes()
                if len(bodyBytes) &gt; 0 &amp;&amp; bodyBytes[len(bodyBytes)-1] == '\n' </span><span class="cov8" title="1">{
                        current.Body = finalizeBody(bodyBytes)
                        messages = append(messages, current)
                }</span>
        }
        <span class="cov8" title="1">return messages, nil</span>
}

func finalizeBody(body []byte) string <span class="cov8" title="1">{
        if len(body) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">text := string(body)
        text = strings.TrimSuffix(text, "\n")
        text = strings.TrimSuffix(text, "\r")
        return text</span>
}

func filterSince(messages []*Message, sinceID string) ([]*Message, error) <span class="cov8" title="1">{
        if strings.TrimSpace(sinceID) == "" </span><span class="cov8" title="1">{
                return messages, nil
        }</span>
        <span class="cov8" title="1">for i, msg := range messages </span><span class="cov8" title="1">{
                if msg != nil &amp;&amp; msg.MsgID == sinceID </span><span class="cov8" title="1">{
                        if i+1 &gt;= len(messages) </span><span class="cov8" title="1">{
                                return []*Message{}, nil
                        }</span>
                        <span class="cov8" title="1">return messages[i+1:], nil</span>
                }
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("since id %q not found: %w", sinceID, ErrSinceIDNotFound)</span>
}

func validateBusPath(path string) error <span class="cov8" title="1">{
        if strings.TrimSpace(path) == "" </span><span class="cov0" title="0">{
                return errors.New("message bus path is empty")
        }</span>
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "stat message bus path")</span>
        }
        <span class="cov8" title="1">if info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov8" title="1">{
                return errors.Errorf("message bus path %q is a symlink", path)
        }</span>
        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov8" title="1">{
                return errors.Errorf("message bus path %q is not a regular file", path)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package messagebus

import (
        "fmt"
        "os"
        "sync/atomic"
        "time"
)

var msgSequence uint32

// GenerateMessageID returns a unique, lexically sortable message ID.
func GenerateMessageID() string <span class="cov8" title="1">{
        now := time.Now().UTC()
        seq := atomic.AddUint32(&amp;msgSequence, 1) % 10000
        pid := os.Getpid() % 100000
        return fmt.Sprintf("MSG-%s-%09d-PID%05d-%04d", now.Format("20060102-150405"), now.Nanosecond(), pid, seq)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package runner

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/agent"
        "github.com/jonnyzzz/conductor-loop/internal/agent/perplexity"
        "github.com/jonnyzzz/conductor-loop/internal/agent/xai"
        "github.com/jonnyzzz/conductor-loop/internal/messagebus"
        "github.com/jonnyzzz/conductor-loop/internal/storage"
        "github.com/pkg/errors"
)

// JobOptions controls execution for a single run-agent job.
type JobOptions struct {
        RootDir        string
        ConfigPath     string
        Agent          string
        Prompt         string
        PromptPath     string
        WorkingDir     string
        MessageBusPath string
        ParentRunID    string
        PreviousRunID  string
        Environment    map[string]string
}

// RunJob starts a single agent run and waits for completion.
func RunJob(projectID, taskID string, opts JobOptions) error <span class="cov8" title="1">{
        _, err := runJob(projectID, taskID, opts)
        return err
}</span>

func runJob(projectID, taskID string, opts JobOptions) (*storage.RunInfo, error) <span class="cov8" title="1">{
        rootDir, err := resolveRootDir(opts.RootDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">taskDir, err := resolveTaskDir(rootDir, projectID, taskID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := ensureDir(taskDir); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "ensure task dir")
        }</span>

        <span class="cov8" title="1">promptText, err := resolvePrompt(opts)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">workingDir := strings.TrimSpace(opts.WorkingDir)
        if workingDir == "" </span><span class="cov8" title="1">{
                workingDir = taskDir
        }</span>
        <span class="cov8" title="1">workingDir, err = absPath(workingDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "resolve working dir")
        }</span>

        <span class="cov8" title="1">busPath := strings.TrimSpace(opts.MessageBusPath)
        if busPath == "" </span><span class="cov8" title="1">{
                busPath = filepath.Join(taskDir, "TASK-MESSAGE-BUS.md")
        }</span>

        <span class="cov8" title="1">runsDir := filepath.Join(taskDir, "runs")
        if err := ensureDir(runsDir); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "ensure runs dir")
        }</span>
        <span class="cov8" title="1">runID, runDir, err := createRunDir(runsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">promptPath := filepath.Join(runDir, "prompt.md")
        promptContent := buildPrompt(taskDir, runDir, promptText)
        if err := os.WriteFile(promptPath, []byte(promptContent), 0o644); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "write prompt")
        }</span>

        <span class="cov8" title="1">cfg, err := loadConfig(opts.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">selection, err := selectAgent(cfg, opts.Agent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">agentType := strings.ToLower(strings.TrimSpace(selection.Type))
        if agentType == "" </span><span class="cov0" title="0">{
                agentType = strings.ToLower(strings.TrimSpace(opts.Agent))
        }</span>
        <span class="cov8" title="1">if agentType == "" </span><span class="cov0" title="0">{
                return nil, errors.New("agent type is empty")
        }</span>

        <span class="cov8" title="1">envOverrides := map[string]string{
                "JRUN_PROJECT_ID": projectID,
                "JRUN_TASK_ID":    taskID,
                "JRUN_ID":         runID,
                "JRUN_PARENT_ID":  strings.TrimSpace(opts.ParentRunID),
        }
        if tokenVar := tokenEnvVar(agentType); tokenVar != "" </span><span class="cov8" title="1">{
                if token := strings.TrimSpace(selection.Config.Token); token != "" </span><span class="cov8" title="1">{
                        envOverrides[tokenVar] = token
                }</span>
        }
        <span class="cov8" title="1">if err := prependPath(envOverrides); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for key, value := range opts.Environment </span><span class="cov0" title="0">{
                if strings.TrimSpace(key) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">envOverrides[key] = value</span>
        }

        <span class="cov8" title="1">env := mergeEnv(os.Environ(), envOverrides)

        runDirAbs, err := absPath(runDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "resolve run dir")
        }</span>
        <span class="cov8" title="1">promptPathAbs := filepath.Join(runDirAbs, "prompt.md")
        outputPathAbs := filepath.Join(runDirAbs, "output.md")
        stdoutPathAbs := filepath.Join(runDirAbs, "agent-stdout.txt")
        stderrPathAbs := filepath.Join(runDirAbs, "agent-stderr.txt")

        info := &amp;storage.RunInfo{
                Version:       1,
                RunID:         runID,
                ParentRunID:   strings.TrimSpace(opts.ParentRunID),
                PreviousRunID: strings.TrimSpace(opts.PreviousRunID),
                ProjectID:     projectID,
                TaskID:        taskID,
                AgentType:     agentType,
                StartTime:     time.Now().UTC(),
                ExitCode:      -1,
                Status:        storage.StatusRunning,
                CWD:           workingDir,
                PromptPath:    promptPathAbs,
                OutputPath:    outputPathAbs,
                StdoutPath:    stdoutPathAbs,
                StderrPath:    stderrPathAbs,
        }

        var execErr error
        if isRestAgent(agentType) </span><span class="cov8" title="1">{
                execErr = executeREST(ctxOrBackground(), agentType, selection, promptContent, workingDir, env, runDir, busPath, info)
        }</span> else<span class="cov8" title="1"> {
                execErr = executeCLI(ctxOrBackground(), agentType, promptPathAbs, workingDir, env, runDir, busPath, info)
        }</span>

        <span class="cov8" title="1">if execErr != nil </span><span class="cov8" title="1">{
                return info, execErr
        }</span>
        <span class="cov8" title="1">return info, nil</span>
}

func resolvePrompt(opts JobOptions) (string, error) <span class="cov8" title="1">{
        if path := strings.TrimSpace(opts.PromptPath); path != "" </span><span class="cov8" title="1">{
                return readFileTrimmed(path)
        }</span>
        <span class="cov8" title="1">if prompt := strings.TrimSpace(opts.Prompt); prompt != "" </span><span class="cov8" title="1">{
                return prompt, nil
        }</span>
        <span class="cov8" title="1">return "", errors.New("prompt is empty")</span>
}

func isRestAgent(agentType string) bool <span class="cov8" title="1">{
        switch strings.ToLower(agentType) </span>{
        case "perplexity", "xai":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func executeCLI(ctx context.Context, agentType, promptPath, workingDir string, env []string, runDir, busPath string, info *storage.RunInfo) error <span class="cov8" title="1">{
        command, args, err := commandForAgent(agentType, workingDir)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">promptFile, err := os.Open(promptPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "open prompt")
        }</span>
        <span class="cov8" title="1">pm, err := NewProcessManager(runDir)
        if err != nil </span><span class="cov0" title="0">{
                _ = promptFile.Close()
                return err
        }</span>
        <span class="cov8" title="1">proc, err := pm.SpawnAgent(ctx, agentType, SpawnOptions{
                Command: command,
                Args:    args,
                Dir:     workingDir,
                Env:     env,
                Stdin:   promptFile,
        })
        _ = promptFile.Close()
        if err != nil </span><span class="cov0" title="0">{
                pid := os.Getpid()
                pgid := pid
                if resolved, resolveErr := ProcessGroupID(pid); resolveErr == nil </span><span class="cov0" title="0">{
                        pgid = resolved
                }</span>
                <span class="cov0" title="0">info.PID = pid
                info.PGID = pgid
                info.EndTime = time.Now().UTC()
                info.ExitCode = -1
                info.Status = storage.StatusFailed
                if writeErr := storage.WriteRunInfo(filepath.Join(runDir, "run-info.yaml"), info); writeErr != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(writeErr, "write run-info")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "spawn agent")</span>
        }
        <span class="cov8" title="1">info.PID = proc.PID
        info.PGID = proc.PGID
        info.CommandLine = fmt.Sprintf("%s %s &lt; %s", command, strings.Join(args, " "), promptPath)
        if err := storage.WriteRunInfo(filepath.Join(runDir, "run-info.yaml"), info); err != nil </span><span class="cov0" title="0">{
                _ = proc.Cmd.Process.Kill()
                _ = proc.Wait()
                return errors.Wrap(err, "write run-info")
        }</span>
        <span class="cov8" title="1">if err := postRunEvent(busPath, info, "RUN_START", "run started"); err != nil </span><span class="cov8" title="1">{
                _ = proc.Cmd.Process.Kill()
                _ = proc.Wait()
                return err
        }</span>

        <span class="cov8" title="1">waitErr := proc.Wait()
        exitCode := 0
        if proc.Cmd.ProcessState != nil </span><span class="cov8" title="1">{
                exitCode = proc.Cmd.ProcessState.ExitCode()
        }</span>
        <span class="cov8" title="1">info.ExitCode = exitCode
        info.EndTime = time.Now().UTC()
        if exitCode == 0 &amp;&amp; waitErr == nil </span><span class="cov8" title="1">{
                info.Status = storage.StatusCompleted
        }</span> else<span class="cov8" title="1"> {
                info.Status = storage.StatusFailed
        }</span>
        <span class="cov8" title="1">if err := storage.UpdateRunInfo(filepath.Join(runDir, "run-info.yaml"), func(update *storage.RunInfo) error </span><span class="cov8" title="1">{
                update.ExitCode = info.ExitCode
                update.EndTime = info.EndTime
                update.Status = info.Status
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                return errors.Wrap(err, "update run-info")
        }</span>
        <span class="cov8" title="1">if _, err := agent.CreateOutputMD(runDir, ""); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "ensure output.md")
        }</span>
        <span class="cov8" title="1">if err := postRunEvent(busPath, info, "RUN_STOP", fmt.Sprintf("run stopped with code %d", info.ExitCode)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if waitErr != nil || exitCode != 0 </span><span class="cov8" title="1">{
                return errors.Wrap(waitErr, "agent execution failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func executeREST(ctx context.Context, agentType string, selection agentSelection, promptContent, workingDir string, env []string, runDir, busPath string, info *storage.RunInfo) error <span class="cov8" title="1">{
        pid := os.Getpid()
        pgid := pid
        if resolved, err := ProcessGroupID(pid); err == nil </span><span class="cov8" title="1">{
                pgid = resolved
        }</span>
        <span class="cov8" title="1">info.PID = pid
        info.PGID = pgid
        if err := storage.WriteRunInfo(filepath.Join(runDir, "run-info.yaml"), info); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write run-info")
        }</span>
        <span class="cov8" title="1">if err := postRunEvent(busPath, info, "RUN_START", "run started"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var execErr error
        runCtx := &amp;agent.RunContext{
                RunID:       info.RunID,
                ProjectID:   info.ProjectID,
                TaskID:      info.TaskID,
                Prompt:      promptContent,
                WorkingDir:  workingDir,
                StdoutPath:  info.StdoutPath,
                StderrPath:  info.StderrPath,
                Environment: envMap(env),
        }
        switch strings.ToLower(agentType) </span>{
        case "perplexity":<span class="cov0" title="0">
                agentImpl := perplexity.NewPerplexityAgent(perplexity.Options{
                        Token:       selection.Config.Token,
                        Model:       selection.Config.Model,
                        APIEndpoint: selection.Config.BaseURL,
                })
                execErr = agentImpl.Execute(ctx, runCtx)</span>
        case "xai":<span class="cov8" title="1">
                agentImpl, err := xai.NewAgent(xai.Config{
                        APIKey:  selection.Config.Token,
                        BaseURL: selection.Config.BaseURL,
                        Model:   selection.Config.Model,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">execErr = agentImpl.Execute(ctx, runCtx)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported rest agent %q", agentType)</span>
        }
        <span class="cov8" title="1">return finalizeRun(runDir, busPath, info, execErr)</span>
}

func finalizeRun(runDir, busPath string, info *storage.RunInfo, execErr error) error <span class="cov8" title="1">{
        if info == nil </span><span class="cov8" title="1">{
                return errors.New("run info is nil")
        }</span>
        <span class="cov8" title="1">info.EndTime = time.Now().UTC()
        if execErr != nil </span><span class="cov8" title="1">{
                info.ExitCode = 1
                info.Status = storage.StatusFailed
        }</span> else<span class="cov8" title="1"> {
                info.ExitCode = 0
                info.Status = storage.StatusCompleted
        }</span>
        <span class="cov8" title="1">if err := storage.UpdateRunInfo(filepath.Join(runDir, "run-info.yaml"), func(update *storage.RunInfo) error </span><span class="cov8" title="1">{
                update.ExitCode = info.ExitCode
                update.EndTime = info.EndTime
                update.Status = info.Status
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                return errors.Wrap(err, "update run-info")
        }</span>
        <span class="cov8" title="1">if _, err := agent.CreateOutputMD(runDir, ""); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "ensure output.md")
        }</span>
        <span class="cov8" title="1">if err := postRunEvent(busPath, info, "RUN_STOP", fmt.Sprintf("run stopped with code %d", info.ExitCode)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if execErr != nil </span><span class="cov8" title="1">{
                return errors.Wrap(execErr, "agent execution failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func postRunEvent(busPath string, info *storage.RunInfo, msgType, body string) error <span class="cov8" title="1">{
        if info == nil </span><span class="cov0" title="0">{
                return errors.New("run info is nil")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(busPath) == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">bus, err := messagebus.NewMessageBus(busPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "new message bus")
        }</span>
        <span class="cov8" title="1">_, err = bus.AppendMessage(&amp;messagebus.Message{
                Type:      msgType,
                ProjectID: info.ProjectID,
                TaskID:    info.TaskID,
                RunID:     info.RunID,
                Body:      body,
        })
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "append message")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func commandForAgent(agentType, workingDir string) (string, []string, error) <span class="cov8" title="1">{
        switch strings.ToLower(agentType) </span>{
        case "codex":<span class="cov8" title="1">
                args := []string{"exec", "--dangerously-bypass-approvals-and-sandbox", "-"}
                if strings.TrimSpace(workingDir) != "" </span><span class="cov8" title="1">{
                        args = []string{"exec", "--dangerously-bypass-approvals-and-sandbox", "-C", workingDir, "-"}
                }</span>
                <span class="cov8" title="1">return "codex", args, nil</span>
        case "claude":<span class="cov8" title="1">
                args := []string{
                        "-p",
                        "--input-format",
                        "text",
                        "--output-format",
                        "text",
                        "--tools",
                        "default",
                        "--permission-mode",
                        "bypassPermissions",
                }
                if strings.TrimSpace(workingDir) != "" </span><span class="cov8" title="1">{
                        args = append([]string{"-C", workingDir}, args...)
                }</span>
                <span class="cov8" title="1">return "claude", args, nil</span>
        case "gemini":<span class="cov8" title="1">
                args := []string{"--screen-reader", "true", "--approval-mode", "yolo"}
                return "gemini", args, nil</span>
        default:<span class="cov8" title="1">
                return "", nil, fmt.Errorf("unsupported agent type %q", agentType)</span>
        }
}

func envMap(env []string) map[string]string <span class="cov8" title="1">{
        values := make(map[string]string)
        for _, entry := range env </span><span class="cov8" title="1">{
                if entry == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts := strings.SplitN(entry, "=", 2)
                key := strings.TrimSpace(parts[0])
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value := ""
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        value = parts[1]
                }</span>
                <span class="cov8" title="1">values[key] = value</span>
        }
        <span class="cov8" title="1">return values</span>
}

func ctxOrBackground() context.Context <span class="cov8" title="1">{
        return context.Background()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package runner manages agent process execution for the orchestration subsystem.
package runner

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync/atomic"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/config"
        "github.com/pkg/errors"
)

var runCounter uint64

type agentSelection struct {
        Name   string
        Type   string
        Config config.AgentConfig
}

func resolveRootDir(root string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(root)
        if trimmed == "" </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "resolve home dir")
                }</span>
                <span class="cov8" title="1">trimmed = filepath.Join(home, "run-agent")</span>
        }
        <span class="cov8" title="1">abs, err := filepath.Abs(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "resolve root dir")
        }</span>
        <span class="cov8" title="1">return abs, nil</span>
}

func resolveTaskDir(rootDir, projectID, taskID string) (string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(projectID) == "" </span><span class="cov8" title="1">{
                return "", errors.New("project id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(taskID) == "" </span><span class="cov8" title="1">{
                return "", errors.New("task id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(rootDir) == "" </span><span class="cov8" title="1">{
                return "", errors.New("root dir is empty")
        }</span>
        <span class="cov8" title="1">return filepath.Join(rootDir, projectID, taskID), nil</span>
}

func loadConfig(path string) (*config.Config, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(path)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">cfg, err := config.LoadConfig(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "load config")
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

func selectAgent(cfg *config.Config, preferred string) (agentSelection, error) <span class="cov8" title="1">{
        preferred = strings.TrimSpace(preferred)
        if cfg == nil </span><span class="cov8" title="1">{
                if preferred == "" </span><span class="cov8" title="1">{
                        return agentSelection{}, errors.New("agent is empty")
                }</span>
                <span class="cov8" title="1">return agentSelection{Name: preferred, Type: strings.ToLower(preferred)}, nil</span>
        }
        <span class="cov8" title="1">if preferred != "" </span><span class="cov8" title="1">{
                if agentCfg, ok := cfg.Agents[preferred]; ok </span><span class="cov8" title="1">{
                        return agentSelection{Name: preferred, Type: agentCfg.Type, Config: agentCfg}, nil
                }</span>
                <span class="cov8" title="1">for name, agentCfg := range cfg.Agents </span><span class="cov8" title="1">{
                        if agentCfg.Type == strings.ToLower(preferred) </span><span class="cov8" title="1">{
                                return agentSelection{Name: name, Type: agentCfg.Type, Config: agentCfg}, nil
                        }</span>
                }
                <span class="cov8" title="1">return agentSelection{}, fmt.Errorf("unknown agent %q", preferred)</span>
        }

        <span class="cov8" title="1">if cfg.Defaults.Agent != "" </span><span class="cov8" title="1">{
                return selectAgent(cfg, cfg.Defaults.Agent)
        }</span>
        <span class="cov8" title="1">if len(cfg.Agents) == 0 </span><span class="cov8" title="1">{
                return agentSelection{}, errors.New("no agents configured")
        }</span>
        <span class="cov0" title="0">keys := make([]string, 0, len(cfg.Agents))
        for key := range cfg.Agents </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        name := keys[0]
        agentCfg := cfg.Agents[name]
        return agentSelection{Name: name, Type: agentCfg.Type, Config: agentCfg}, nil</span>
}

func newRunID(now time.Time, pid int) string <span class="cov8" title="1">{
        offset := atomic.AddUint64(&amp;runCounter, 1)
        if offset != 0 </span><span class="cov8" title="1">{
                now = now.Add(time.Duration(offset%10000) * 100 * time.Microsecond)
        }</span>
        <span class="cov8" title="1">stamp := now.UTC().Format("20060102-1504050000")
        return fmt.Sprintf("%s-%d", stamp, pid)</span>
}

func createRunDir(runsDir string) (string, string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(runsDir) == "" </span><span class="cov8" title="1">{
                return "", "", errors.New("runs directory is empty")
        }</span>
        <span class="cov8" title="1">pid := os.Getpid()
        runID := newRunID(time.Now().UTC(), pid)
        runDir := filepath.Join(runsDir, runID)
        if err := os.Mkdir(runDir, 0o755); err == nil </span><span class="cov8" title="1">{
                return runID, runDir, nil
        }</span> else<span class="cov8" title="1"> if !os.IsExist(err) </span><span class="cov8" title="1">{
                return "", "", errors.Wrap(err, "create run directory")
        }</span>
        <span class="cov0" title="0">fallback, err := os.MkdirTemp(runsDir, runID+"-")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.Wrap(err, "create run directory")
        }</span>
        <span class="cov0" title="0">return filepath.Base(fallback), fallback, nil</span>
}

func buildPrompt(taskDir, runDir, prompt string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(prompt)
        preamble := fmt.Sprintf("TASK_FOLDER=%s\nRUN_FOLDER=%s\nWrite output.md to %s\n\n", taskDir, runDir, filepath.Join(runDir, "output.md"))
        if trimmed == "" </span><span class="cov0" title="0">{
                return preamble
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(trimmed, "\n") </span><span class="cov8" title="1">{
                trimmed += "\n"
        }</span>
        <span class="cov8" title="1">return preamble + trimmed</span>
}

func ensureDir(path string) error <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(path))
        if clean == "." || clean == "" </span><span class="cov8" title="1">{
                return errors.New("directory is empty")
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(clean, 0o755); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "create directory")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func readFileTrimmed(path string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, "read file")
        }</span>
        <span class="cov8" title="1">trimmed := strings.TrimSpace(string(data))
        if trimmed == "" </span><span class="cov8" title="1">{
                return "", errors.New("file is empty")
        }</span>
        <span class="cov8" title="1">return trimmed, nil</span>
}

func tokenEnvVar(agentType string) string <span class="cov8" title="1">{
        switch strings.ToLower(agentType) </span>{
        case "codex":<span class="cov8" title="1">
                return "OPENAI_API_KEY"</span>
        case "claude":<span class="cov8" title="1">
                return "ANTHROPIC_API_KEY"</span>
        case "gemini":<span class="cov8" title="1">
                return "GEMINI_API_KEY"</span>
        case "perplexity":<span class="cov8" title="1">
                return "PERPLEXITY_API_KEY"</span>
        case "xai":<span class="cov8" title="1">
                return "XAI_API_KEY"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

func mergeEnv(base []string, overrides map[string]string) []string <span class="cov8" title="1">{
        merged := make(map[string]string, len(base)+len(overrides))
        for _, entry := range base </span><span class="cov8" title="1">{
                if entry == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts := strings.SplitN(entry, "=", 2)
                key := strings.TrimSpace(parts[0])
                if key == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value := ""
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        value = parts[1]
                }</span>
                <span class="cov8" title="1">merged[key] = value</span>
        }
        <span class="cov8" title="1">for key, value := range overrides </span><span class="cov8" title="1">{
                cleanKey := strings.TrimSpace(key)
                if cleanKey == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">merged[cleanKey] = value</span>
        }
        <span class="cov8" title="1">keys := make([]string, 0, len(merged))
        for key := range merged </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        result := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                result = append(result, key+"="+merged[key])
        }</span>
        <span class="cov8" title="1">return result</span>
}

func prependPath(env map[string]string) error <span class="cov8" title="1">{
        if env == nil </span><span class="cov8" title="1">{
                return errors.New("env is nil")
        }</span>
        <span class="cov8" title="1">execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "resolve executable")
        }</span>
        <span class="cov8" title="1">execDir := filepath.Dir(execPath)
        existing := env["PATH"]
        if existing == "" </span><span class="cov8" title="1">{
                existing = os.Getenv("PATH")
        }</span>
        <span class="cov8" title="1">if existing == "" </span><span class="cov0" title="0">{
                env["PATH"] = execDir
                return nil
        }</span>
        <span class="cov8" title="1">env["PATH"] = execDir + string(os.PathListSeparator) + existing
        return nil</span>
}

func absPath(path string) (string, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(path)
        if trimmed == "" </span><span class="cov8" title="1">{
                return "", errors.New("path is empty")
        }</span>
        <span class="cov8" title="1">abs, err := filepath.Abs(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "resolve absolute path")
        }</span>
        <span class="cov8" title="1">return abs, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package runner

import (
        "os/exec"

        "github.com/pkg/errors"
)

// ProcessGroupID returns the process group id for the given pid.
func ProcessGroupID(pid int) (int, error) <span class="cov8" title="1">{
        if pid &lt;= 0 </span><span class="cov8" title="1">{
                return 0, errors.New("pid is invalid")
        }</span>
        <span class="cov8" title="1">return getProcessGroupID(pid)</span>
}

func configureProcessGroup(cmd *exec.Cmd) <span class="cov8" title="1">{
        applyProcessGroup(cmd)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:build !windows

package runner

import (
        "os/exec"
        "syscall"

        "github.com/pkg/errors"
)

func applyProcessGroup(cmd *exec.Cmd) <span class="cov8" title="1">{
        if cmd == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if cmd.SysProcAttr == nil </span><span class="cov8" title="1">{
                cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        }</span>
        <span class="cov8" title="1">cmd.SysProcAttr.Setsid = true</span>
}

func getProcessGroupID(pid int) (int, error) <span class="cov8" title="1">{
        pgid, err := syscall.Getpgid(pid)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "get pgid")
        }</span>
        <span class="cov8" title="1">return pgid, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package runner manages agent process execution for the orchestration subsystem.
package runner

import (
        "context"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
)

// ProcessManager spawns agent processes within a run directory.
type ProcessManager struct {
        runDir string
}

// SpawnOptions controls how a process is started.
type SpawnOptions struct {
        Command string
        Args    []string
        Dir     string
        Env     []string
        Stdin   io.Reader
        Stdout  io.Writer
        Stderr  io.Writer
}

// Process represents a spawned agent process and its metadata.
type Process struct {
        Cmd        *exec.Cmd
        PID        int
        PGID       int
        StdoutPath string
        StderrPath string

        capture *StdioCapture
}

// NewProcessManager creates a ProcessManager for the given run directory.
func NewProcessManager(runDir string) (*ProcessManager, error) <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(runDir))
        if clean == "." || clean == "" </span><span class="cov8" title="1">{
                return nil, errors.New("run directory is empty")
        }</span>
        <span class="cov8" title="1">return &amp;ProcessManager{runDir: clean}, nil</span>
}

// SpawnAgent starts a detached process with redirected stdio.
func (pm *ProcessManager) SpawnAgent(ctx context.Context, agentType string, opts SpawnOptions) (*Process, error) <span class="cov8" title="1">{
        if pm == nil </span><span class="cov0" title="0">{
                return nil, errors.New("process manager is nil")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(agentType) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("agent type is empty")
        }</span>
        <span class="cov8" title="1">command := strings.TrimSpace(opts.Command)
        if command == "" </span><span class="cov8" title="1">{
                return nil, errors.New("command is empty")
        }</span>
        <span class="cov8" title="1">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, command, opts.Args...)
        if dir := strings.TrimSpace(opts.Dir); dir != "" </span><span class="cov8" title="1">{
                cmd.Dir = dir
        }</span>
        <span class="cov8" title="1">if len(opts.Env) &gt; 0 </span><span class="cov8" title="1">{
                cmd.Env = opts.Env
        }</span>

        <span class="cov8" title="1">capture, err := OpenStdio(pm.runDir, opts.Stdout, opts.Stderr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "open stdio")
        }</span>
        <span class="cov8" title="1">cmd.Stdout = capture.Stdout
        cmd.Stderr = capture.Stderr

        stdin := opts.Stdin
        var stdinFile *os.File
        if stdin == nil </span><span class="cov8" title="1">{
                stdinFile, err = os.OpenFile(os.DevNull, os.O_RDONLY, 0o644)
                if err != nil </span><span class="cov0" title="0">{
                        _ = capture.Close()
                        return nil, errors.Wrap(err, "open stdin")
                }</span>
                <span class="cov8" title="1">stdin = stdinFile</span>
        }
        <span class="cov8" title="1">cmd.Stdin = stdin

        configureProcessGroup(cmd)

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                if stdinFile != nil </span><span class="cov0" title="0">{
                        _ = stdinFile.Close()
                }</span>
                <span class="cov0" title="0">_ = capture.Close()
                return nil, errors.Wrap(err, "start process")</span>
        }
        <span class="cov8" title="1">if stdinFile != nil </span><span class="cov8" title="1">{
                _ = stdinFile.Close()
        }</span>

        <span class="cov8" title="1">pid := cmd.Process.Pid
        pgid, err := ProcessGroupID(pid)
        if err != nil </span><span class="cov0" title="0">{
                _ = capture.Close()
                return nil, errors.Wrap(err, "get process group id")
        }</span>

        <span class="cov8" title="1">return &amp;Process{
                Cmd:        cmd,
                PID:        pid,
                PGID:       pgid,
                StdoutPath: capture.StdoutPath,
                StderrPath: capture.StderrPath,
                capture:    capture,
        }, nil</span>
}

// Wait waits for the process to exit and closes stdout/stderr files.
func (p *Process) Wait() error <span class="cov8" title="1">{
        if p == nil || p.Cmd == nil </span><span class="cov8" title="1">{
                return errors.New("process is nil")
        }</span>
        <span class="cov8" title="1">if err := p.Cmd.Wait(); err != nil </span><span class="cov8" title="1">{
                _ = p.closeCapture()
                return errors.Wrap(err, "wait process")
        }</span>
        <span class="cov8" title="1">return p.closeCapture()</span>
}

func (p *Process) closeCapture() error <span class="cov8" title="1">{
        if p == nil || p.capture == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := p.capture.Close(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "close stdio")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package runner manages agent process execution for the orchestration subsystem.
package runner

import (
        "context"
        stderrors "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/messagebus"
        "github.com/pkg/errors"
)

const (
        defaultRalphWaitTimeout  = 300 * time.Second
        defaultRalphPollInterval = time.Second
        defaultRalphMaxRestarts  = 100
        defaultRalphRestartDelay = time.Second
)

// RootRunner executes one root agent run.
type RootRunner func(ctx context.Context, attempt int) error

// RalphLoop implements the root agent restart loop.
type RalphLoop struct {
        runDir      string
        messagebus  *messagebus.MessageBus
        maxRestarts int
        waitTimeout time.Duration

        pollInterval time.Duration
        restartDelay time.Duration
        projectID    string
        taskID       string
        runRoot      RootRunner
}

// RalphOption configures the Ralph loop.
type RalphOption func(*RalphLoop)

// NewRalphLoop constructs a RalphLoop with defaults and validation.
func NewRalphLoop(runDir string, bus *messagebus.MessageBus, opts ...RalphOption) (*RalphLoop, error) <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(runDir))
        if clean == "." || clean == "" </span><span class="cov8" title="1">{
                return nil, errors.New("run directory is empty")
        }</span>
        <span class="cov8" title="1">if bus == nil </span><span class="cov8" title="1">{
                return nil, errors.New("message bus is nil")
        }</span>
        <span class="cov8" title="1">info, err := os.Stat(clean)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "stat run directory")
        }</span>
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, errors.New("run directory is not a directory")
        }</span>

        <span class="cov8" title="1">rl := &amp;RalphLoop{
                runDir:       clean,
                messagebus:   bus,
                maxRestarts:  defaultRalphMaxRestarts,
                waitTimeout:  defaultRalphWaitTimeout,
                pollInterval: defaultRalphPollInterval,
                restartDelay: defaultRalphRestartDelay,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if opt != nil </span><span class="cov8" title="1">{
                        opt(rl)
                }</span>
        }
        <span class="cov8" title="1">if rl.waitTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("wait timeout must be positive")
        }</span>
        <span class="cov8" title="1">if rl.pollInterval &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("poll interval must be positive")
        }</span>
        <span class="cov8" title="1">if rl.restartDelay &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("restart delay must not be negative")
        }</span>
        <span class="cov8" title="1">if rl.maxRestarts &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("max restarts must not be negative")
        }</span>
        <span class="cov8" title="1">if rl.runRoot == nil </span><span class="cov8" title="1">{
                return nil, errors.New("root runner is nil")
        }</span>
        <span class="cov8" title="1">if rl.projectID == "" || rl.taskID == "" </span><span class="cov0" title="0">{
                projectID, taskID := inferProjectTaskID(clean)
                if rl.projectID == "" </span><span class="cov0" title="0">{
                        rl.projectID = projectID
                }</span>
                <span class="cov0" title="0">if rl.taskID == "" </span><span class="cov0" title="0">{
                        rl.taskID = taskID
                }</span>
        }
        <span class="cov8" title="1">if rl.projectID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("project id is empty")
        }</span>

        <span class="cov8" title="1">return rl, nil</span>
}

// WithMaxRestarts overrides the maximum restarts.
func WithMaxRestarts(max int) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.maxRestarts = max
        }</span>
}

// WithWaitTimeout overrides the child wait timeout.
func WithWaitTimeout(timeout time.Duration) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.waitTimeout = timeout
        }</span>
}

// WithPollInterval overrides the child polling interval.
func WithPollInterval(interval time.Duration) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.pollInterval = interval
        }</span>
}

// WithRestartDelay overrides the pause between restarts.
func WithRestartDelay(delay time.Duration) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.restartDelay = delay
        }</span>
}

// WithProjectTask sets project/task identifiers for message bus entries.
func WithProjectTask(projectID, taskID string) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.projectID = strings.TrimSpace(projectID)
                rl.taskID = strings.TrimSpace(taskID)
        }</span>
}

// WithRootRunner sets the root runner callback.
func WithRootRunner(run RootRunner) RalphOption <span class="cov8" title="1">{
        return func(rl *RalphLoop) </span><span class="cov8" title="1">{
                rl.runRoot = run
        }</span>
}

// Run executes the Ralph loop until completion or error.
func (rl *RalphLoop) Run(ctx context.Context) error <span class="cov8" title="1">{
        if rl == nil </span><span class="cov0" title="0">{
                return errors.New("ralph loop is nil")
        }</span>
        <span class="cov8" title="1">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov8" title="1">restarts := 0
        for </span><span class="cov8" title="1">{
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">done, err := rl.doneExists()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if done </span><span class="cov8" title="1">{
                        return rl.handleDone(ctx)
                }</span>
                <span class="cov8" title="1">if restarts &gt;= rl.maxRestarts </span><span class="cov8" title="1">{
                        if logErr := rl.appendMessage("ERROR", fmt.Sprintf("task failed: max restarts (%d) exceeded", rl.maxRestarts)); logErr != nil </span><span class="cov0" title="0">{
                                return logErr
                        }</span>
                        <span class="cov8" title="1">return errors.New("max restarts exceeded")</span>
                }

                <span class="cov8" title="1">if err := rl.appendMessage("INFO", fmt.Sprintf("starting root agent (restart #%d)", restarts)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := rl.runRoot(ctx, restarts); err != nil </span><span class="cov8" title="1">{
                        if logErr := rl.appendMessage("WARNING", fmt.Sprintf("root agent failed on restart #%d: %v", restarts, err)); logErr != nil </span><span class="cov0" title="0">{
                                return logErr
                        }</span>
                }
                <span class="cov8" title="1">restarts++

                done, err = rl.doneExists()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if done </span><span class="cov8" title="1">{
                        return rl.handleDone(ctx)
                }</span>

                <span class="cov8" title="1">if err := sleepWithContext(ctx, rl.restartDelay); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
}

func (rl *RalphLoop) handleDone(ctx context.Context) error <span class="cov8" title="1">{
        children, err := FindActiveChildren(rl.runDir)
        if err != nil </span><span class="cov0" title="0">{
                if logErr := rl.appendMessage("WARNING", fmt.Sprintf("failed to enumerate children: %v", err)); logErr != nil </span><span class="cov0" title="0">{
                        return logErr
                }</span>
        }
        <span class="cov8" title="1">if len(children) == 0 </span><span class="cov8" title="1">{
                return rl.appendMessage("INFO", "task completed (DONE marker present, no active children)")
        }</span>

        <span class="cov8" title="1">childIDs := childRunIDs(children)
        if err := rl.appendMessage("INFO", fmt.Sprintf("waiting for %d children to complete: %s", len(children), childIDs)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">remaining, waitErr := WaitForChildren(ctx, children, rl.waitTimeout, rl.pollInterval)
        if waitErr != nil </span><span class="cov8" title="1">{
                if stderrors.Is(waitErr, ErrChildWaitTimeout) </span><span class="cov8" title="1">{
                        return rl.appendMessage("WARNING", fmt.Sprintf("timeout waiting for children after %s: %s", rl.waitTimeout, childRunIDs(remaining)))
                }</span>
                <span class="cov0" title="0">return waitErr</span>
        }
        <span class="cov8" title="1">return rl.appendMessage("INFO", "task completed (all children finished)")</span>
}

func (rl *RalphLoop) doneExists() (bool, error) <span class="cov8" title="1">{
        path := filepath.Join(rl.runDir, "DONE")
        info, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                if info.IsDir() </span><span class="cov8" title="1">{
                        return false, errors.New("DONE is a directory")
                }</span>
                <span class="cov8" title="1">return true, nil</span>
        }
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, errors.Wrap(err, "stat DONE")</span>
}

func (rl *RalphLoop) appendMessage(msgType, body string) error <span class="cov8" title="1">{
        if rl.messagebus == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msgType) == "" </span><span class="cov8" title="1">{
                return errors.New("message type is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(body) == "" </span><span class="cov8" title="1">{
                return errors.New("message body is empty")
        }</span>
        <span class="cov8" title="1">msg := &amp;messagebus.Message{
                Type:      msgType,
                ProjectID: rl.projectID,
                TaskID:    rl.taskID,
                Body:      body,
        }
        if _, err := rl.messagebus.AppendMessage(msg); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "append message")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func inferProjectTaskID(runDir string) (string, string) <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(runDir))
        if clean == "." || clean == "" </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">taskID := filepath.Base(clean)
        if taskID == "." || taskID == string(filepath.Separator) </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">projectID := filepath.Base(filepath.Dir(clean))
        if projectID == "." || projectID == string(filepath.Separator) </span><span class="cov0" title="0">{
                return "", taskID
        }</span>
        <span class="cov8" title="1">return projectID, taskID</span>
}

func childRunIDs(children []ChildProcess) string <span class="cov8" title="1">{
        if len(children) == 0 </span><span class="cov0" title="0">{
                return "[]"
        }</span>
        <span class="cov8" title="1">ids := make([]string, 0, len(children))
        for _, child := range children </span><span class="cov8" title="1">{
                if strings.TrimSpace(child.RunID) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">ids = append(ids, child.RunID)</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%v", ids)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package runner

import (
        "context"
        "time"
)

func sleepWithContext(ctx context.Context, delay time.Duration) error <span class="cov8" title="1">{
        if delay &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">timer := time.NewTimer(delay)
        defer timer.Stop()
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        case &lt;-timer.C:<span class="cov8" title="1">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package runner

import (
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
)

// StdioCapture holds writers and file handles for captured output.
type StdioCapture struct {
        Stdout io.Writer
        Stderr io.Writer

        StdoutPath string
        StderrPath string

        stdoutFile *os.File
        stderrFile *os.File
}

// OpenStdio opens stdout/stderr files in the run directory.
func OpenStdio(runDir string, stdout, stderr io.Writer) (*StdioCapture, error) <span class="cov8" title="1">{
        cleanRunDir := filepath.Clean(strings.TrimSpace(runDir))
        if cleanRunDir == "." || cleanRunDir == "" </span><span class="cov8" title="1">{
                return nil, errors.New("run directory is empty")
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(cleanRunDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create run directory")
        }</span>

        <span class="cov8" title="1">stdoutPath := filepath.Join(cleanRunDir, "agent-stdout.txt")
        stderrPath := filepath.Join(cleanRunDir, "agent-stderr.txt")

        stdoutFile, err := openAppendFile(stdoutPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "open stdout file")
        }</span>
        <span class="cov8" title="1">stderrFile, err := openAppendFile(stderrPath)
        if err != nil </span><span class="cov0" title="0">{
                _ = stdoutFile.Close()
                return nil, errors.Wrap(err, "open stderr file")
        }</span>

        <span class="cov8" title="1">stdoutWriter := io.Writer(stdoutFile)
        if stdout != nil </span><span class="cov8" title="1">{
                stdoutWriter = io.MultiWriter(stdoutFile, stdout)
        }</span>
        <span class="cov8" title="1">stderrWriter := io.Writer(stderrFile)
        if stderr != nil </span><span class="cov8" title="1">{
                stderrWriter = io.MultiWriter(stderrFile, stderr)
        }</span>

        <span class="cov8" title="1">return &amp;StdioCapture{
                Stdout:     stdoutWriter,
                Stderr:     stderrWriter,
                StdoutPath: stdoutPath,
                StderrPath: stderrPath,
                stdoutFile: stdoutFile,
                stderrFile: stderrFile,
        }, nil</span>
}

// Close closes the underlying stdout/stderr files.
func (c *StdioCapture) Close() error <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return errors.New("stdio capture is nil")
        }</span>
        <span class="cov8" title="1">var firstErr error
        if c.stdoutFile != nil </span><span class="cov8" title="1">{
                if err := c.stdoutFile.Close(); err != nil </span><span class="cov8" title="1">{
                        firstErr = errors.Wrap(err, "close stdout file")
                }</span>
        }
        <span class="cov8" title="1">if c.stderrFile != nil </span><span class="cov8" title="1">{
                if err := c.stderrFile.Close(); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = errors.Wrap(err, "close stderr file")
                }</span>
        }
        <span class="cov8" title="1">return firstErr</span>
}

func openAppendFile(path string) (*os.File, error) <span class="cov8" title="1">{
        if strings.TrimSpace(path) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("output path is empty")
        }</span>
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "create output directory")
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "open output file")
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">//go:build !windows

package runner

import (
        stderrors "errors"
        "syscall"

        "github.com/pkg/errors"
)

// TerminateProcessGroup sends a SIGTERM to the provided process group id.
func TerminateProcessGroup(pgid int) error <span class="cov8" title="1">{
        if pgid &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("pgid is invalid")
        }</span>
        <span class="cov8" title="1">if err := syscall.Kill(-pgid, syscall.SIGTERM); err != nil </span><span class="cov8" title="1">{
                if stderrors.Is(err, syscall.ESRCH) </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "process group not found")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "terminate process group")</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package runner

import (
        "context"
        "path/filepath"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/messagebus"
        "github.com/pkg/errors"
)

// TaskOptions controls execution for the run-agent task command.
type TaskOptions struct {
        RootDir        string
        ConfigPath     string
        Agent          string
        Prompt         string
        WorkingDir     string
        MessageBusPath string
        MaxRestarts    int
        WaitTimeout    time.Duration
        PollInterval   time.Duration
        RestartDelay   time.Duration
        Environment    map[string]string
}

// RunTask starts the root agent and enforces the Ralph loop.
func RunTask(projectID, taskID string, opts TaskOptions) error <span class="cov8" title="1">{
        rootDir, err := resolveRootDir(opts.RootDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">taskDir, err := resolveTaskDir(rootDir, projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ensureDir(taskDir); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "ensure task dir")
        }</span>

        <span class="cov8" title="1">taskPrompt, err := readFileTrimmed(filepath.Join(taskDir, "TASK.md"))
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "read TASK.md")
        }</span>
        <span class="cov8" title="1">prompt := strings.TrimSpace(opts.Prompt)
        if prompt == "" </span><span class="cov8" title="1">{
                prompt = taskPrompt
        }</span>

        <span class="cov8" title="1">busPath := strings.TrimSpace(opts.MessageBusPath)
        if busPath == "" </span><span class="cov8" title="1">{
                busPath = filepath.Join(taskDir, "TASK-MESSAGE-BUS.md")
        }</span>
        <span class="cov8" title="1">bus, err := messagebus.NewMessageBus(busPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "new message bus")
        }</span>

        <span class="cov8" title="1">previousRunID := ""
        runnerFn := func(ctx context.Context, attempt int) error </span><span class="cov8" title="1">{
                jobOpts := JobOptions{
                        RootDir:        opts.RootDir,
                        ConfigPath:     opts.ConfigPath,
                        Agent:          opts.Agent,
                        Prompt:         prompt,
                        WorkingDir:     opts.WorkingDir,
                        MessageBusPath: busPath,
                        PreviousRunID:  previousRunID,
                        Environment:    opts.Environment,
                }
                info, err := runJob(projectID, taskID, jobOpts)
                if info != nil </span><span class="cov8" title="1">{
                        previousRunID = info.RunID
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">options := []RalphOption{
                WithProjectTask(projectID, taskID),
                WithRootRunner(runnerFn),
        }
        if opts.MaxRestarts &gt; 0 </span><span class="cov8" title="1">{
                options = append(options, WithMaxRestarts(opts.MaxRestarts))
        }</span>
        <span class="cov8" title="1">if opts.WaitTimeout &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, WithWaitTimeout(opts.WaitTimeout))
        }</span>
        <span class="cov8" title="1">if opts.PollInterval &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, WithPollInterval(opts.PollInterval))
        }</span>
        <span class="cov8" title="1">if opts.RestartDelay &gt; 0 </span><span class="cov8" title="1">{
                options = append(options, WithRestartDelay(opts.RestartDelay))
        }</span>

        <span class="cov8" title="1">loop, err := NewRalphLoop(taskDir, bus, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return loop.Run(context.Background())</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package runner

import (
        "context"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/jonnyzzz/conductor-loop/internal/storage"
        "github.com/pkg/errors"
)

const (
        defaultChildPollInterval = time.Second
)

// ErrChildWaitTimeout indicates the child wait loop exceeded the timeout.
var ErrChildWaitTimeout = errors.New("child wait timeout")

// ChildProcess captures minimal run metadata for a child process.
type ChildProcess struct {
        RunID       string
        PID         int
        PGID        int
        RunInfoPath string
}

// FindActiveChildren discovers active children for a task run directory.
func FindActiveChildren(runDir string) ([]ChildProcess, error) <span class="cov8" title="1">{
        clean := filepath.Clean(strings.TrimSpace(runDir))
        if clean == "." || clean == "" </span><span class="cov0" title="0">{
                return nil, errors.New("run directory is empty")
        }</span>
        <span class="cov8" title="1">runsDir := filepath.Join(clean, "runs")
        entries, err := os.ReadDir(runsDir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return []ChildProcess{}, nil
                }</span>
                <span class="cov8" title="1">return nil, errors.Wrap(err, "read runs directory")</span>
        }

        <span class="cov8" title="1">var (
                children []ChildProcess
                lastErr  error
        )
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">path := filepath.Join(runsDir, entry.Name(), "run-info.yaml")
                info, err := storage.ReadRunInfo(path)
                if err != nil </span><span class="cov0" title="0">{
                        if lastErr == nil </span><span class="cov0" title="0">{
                                lastErr = errors.Wrapf(err, "read run-info for run %s", entry.Name())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">if !info.EndTime.IsZero() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.TrimSpace(info.ParentRunID) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">alive, err := isProcessGroupAlive(info.PGID)
                if err != nil </span><span class="cov0" title="0">{
                        if lastErr == nil </span><span class="cov0" title="0">{
                                lastErr = errors.Wrapf(err, "check process group for run %s", info.RunID)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">if alive </span><span class="cov8" title="1">{
                        children = append(children, ChildProcess{
                                RunID:       info.RunID,
                                PID:         info.PID,
                                PGID:        info.PGID,
                                RunInfoPath: path,
                        })
                        continue</span>
                }
                <span class="cov8" title="1">markRunInfoFailed(path, time.Now)</span>
        }

        <span class="cov8" title="1">return children, lastErr</span>
}

// WaitForChildren waits for child processes to exit or until timeout.
func WaitForChildren(ctx context.Context, children []ChildProcess, timeout, pollInterval time.Duration) ([]ChildProcess, error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                return children, errors.New("timeout must be positive")
        }</span>
        <span class="cov8" title="1">if pollInterval &lt;= 0 </span><span class="cov0" title="0">{
                pollInterval = defaultChildPollInterval
        }</span>

        <span class="cov8" title="1">deadline := time.Now().Add(timeout)
        remaining := children
        for </span><span class="cov8" title="1">{
                remaining = filterAliveChildren(remaining)
                if len(remaining) == 0 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if time.Now().After(deadline) </span><span class="cov8" title="1">{
                        return remaining, ErrChildWaitTimeout
                }</span>
                <span class="cov8" title="1">if err := sleepWithContext(ctx, pollInterval); err != nil </span><span class="cov8" title="1">{
                        return remaining, err
                }</span>
        }
}

func filterAliveChildren(children []ChildProcess) []ChildProcess <span class="cov8" title="1">{
        if len(children) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">still := make([]ChildProcess, 0, len(children))
        for _, child := range children </span><span class="cov8" title="1">{
                alive, err := isProcessGroupAlive(child.PGID)
                if err != nil </span><span class="cov0" title="0">{
                        still = append(still, child)
                        continue</span>
                }
                <span class="cov8" title="1">if alive </span><span class="cov8" title="1">{
                        still = append(still, child)
                        continue</span>
                }
                <span class="cov8" title="1">markRunInfoFailed(child.RunInfoPath, time.Now)</span>
        }
        <span class="cov8" title="1">return still</span>
}

func markRunInfoFailed(path string, now func() time.Time) <span class="cov8" title="1">{
        if path == "" || now == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_ = storage.UpdateRunInfo(path, func(info *storage.RunInfo) error </span><span class="cov8" title="1">{
                if info == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if !info.EndTime.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">info.EndTime = now().UTC()
                if info.ExitCode == 0 </span><span class="cov8" title="1">{
                        info.ExitCode = -1
                }</span>
                <span class="cov8" title="1">info.Status = storage.StatusFailed
                return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//go:build !windows

package runner

import (
        stderrors "errors"
        "syscall"

        "github.com/pkg/errors"
)

func isProcessGroupAlive(pgid int) (bool, error) <span class="cov8" title="1">{
        if pgid &lt;= 0 </span><span class="cov8" title="1">{
                return false, errors.New("pgid is invalid")
        }</span>
        <span class="cov8" title="1">err := syscall.Kill(-pgid, 0)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if stderrors.Is(err, syscall.ESRCH) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if stderrors.Is(err, syscall.EPERM) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, errors.Wrap(err, "check process group")</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package storage

import (
        "os"
        "path/filepath"
        "runtime"

        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"
)

const runInfoFileMode = 0o644

// WriteRunInfo atomically writes run metadata to the specified path.
func WriteRunInfo(path string, info *RunInfo) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return errors.New("run-info path is empty")
        }</span>
        <span class="cov8" title="1">if info == nil </span><span class="cov8" title="1">{
                return errors.New("run-info is nil")
        }</span>
        <span class="cov8" title="1">data, err := yaml.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "marshal run-info")
        }</span>
        <span class="cov8" title="1">if err := writeFileAtomic(path, data); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write run-info")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReadRunInfo reads run metadata from the specified path.
func ReadRunInfo(path string) (*RunInfo, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return nil, errors.New("run-info path is empty")
        }</span>
        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "read run-info")
        }</span>
        <span class="cov8" title="1">var info RunInfo
        if err := yaml.Unmarshal(data, &amp;info); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "unmarshal run-info")
        }</span>
        <span class="cov8" title="1">return &amp;info, nil</span>
}

// UpdateRunInfo applies updates to run-info.yaml and rewrites it atomically.
func UpdateRunInfo(path string, update func(*RunInfo) error) error <span class="cov8" title="1">{
        if update == nil </span><span class="cov8" title="1">{
                return errors.New("update function is nil")
        }</span>
        <span class="cov8" title="1">info, err := ReadRunInfo(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "read run-info for update")
        }</span>
        <span class="cov8" title="1">if err := update(info); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "apply run-info update")
        }</span>
        <span class="cov8" title="1">if err := WriteRunInfo(path, info); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "rewrite run-info")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeFileAtomic(path string, data []byte) error <span class="cov8" title="1">{
        dir := filepath.Dir(path)
        tmpFile, err := os.CreateTemp(dir, "run-info.*.yaml.tmp")
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "create temp file")
        }</span>
        <span class="cov8" title="1">tmpName := tmpFile.Name()
        success := false
        defer func() </span><span class="cov8" title="1">{
                if success </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">_ = tmpFile.Close()
                _ = os.Remove(tmpName)</span>
        }()

        <span class="cov8" title="1">if _, err := tmpFile.Write(data); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "write temp file")
        }</span>
        <span class="cov8" title="1">if err := tmpFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "fsync temp file")
        }</span>
        <span class="cov8" title="1">if err := tmpFile.Chmod(runInfoFileMode); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "chmod temp file")
        }</span>
        <span class="cov8" title="1">if err := tmpFile.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "close temp file")
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tmpName, path); err != nil </span><span class="cov0" title="0">{
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        if removeErr := os.Remove(path); removeErr == nil </span><span class="cov0" title="0">{
                                if renameErr := os.Rename(tmpName, path); renameErr == nil </span><span class="cov0" title="0">{
                                        success = true
                                        return nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return errors.Wrap(err, "rename temp file")</span>
        }
        <span class="cov8" title="1">success = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package storage

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/pkg/errors"
)

// Storage defines run metadata storage operations.
type Storage interface {
        CreateRun(projectID, taskID, agentType string) (*RunInfo, error)
        UpdateRunStatus(runID string, status string, exitCode int) error
        GetRunInfo(runID string) (*RunInfo, error)
        ListRuns(projectID, taskID string) ([]*RunInfo, error)
}

// FileStorage stores run metadata on disk under the storage root.
type FileStorage struct {
        root     string
        now      func() time.Time
        pid      func() int
        runIndex map[string]string
        mu       sync.RWMutex
}

// NewStorage creates a FileStorage rooted at the provided directory.
func NewStorage(root string) (*FileStorage, error) <span class="cov8" title="1">{
        cleanRoot := filepath.Clean(strings.TrimSpace(root))
        if cleanRoot == "." || cleanRoot == "" </span><span class="cov8" title="1">{
                return nil, errors.New("storage root is empty")
        }</span>
        <span class="cov8" title="1">return &amp;FileStorage{
                root:     cleanRoot,
                now:      time.Now,
                pid:      os.Getpid,
                runIndex: make(map[string]string),
        }, nil</span>
}

// CreateRun creates a new run directory and persists run-info.yaml.
func (s *FileStorage) CreateRun(projectID, taskID, agentType string) (*RunInfo, error) <span class="cov8" title="1">{
        if strings.TrimSpace(projectID) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("project id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(taskID) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("task id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(agentType) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("agent type is empty")
        }</span>

        <span class="cov8" title="1">runID := s.newRunID()
        runDir := filepath.Join(s.root, projectID, taskID, "runs", runID)
        if err := os.MkdirAll(runDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create run directory")
        }</span>

        <span class="cov8" title="1">pid := s.pid()
        info := &amp;RunInfo{
                RunID:     runID,
                ProjectID: projectID,
                TaskID:    taskID,
                AgentType: agentType,
                PID:       pid,
                PGID:      pid,
                StartTime: s.now().UTC(),
                ExitCode:  -1,
                Status:    StatusRunning,
        }
        path := filepath.Join(runDir, "run-info.yaml")
        if err := WriteRunInfo(path, info); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "write run-info")
        }</span>

        <span class="cov8" title="1">s.trackRun(runID, path)
        return info, nil</span>
}

// UpdateRunStatus updates run status, exit code, and end time.
func (s *FileStorage) UpdateRunStatus(runID string, status string, exitCode int) error <span class="cov8" title="1">{
        if strings.TrimSpace(runID) == "" </span><span class="cov8" title="1">{
                return errors.New("run id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(status) == "" </span><span class="cov8" title="1">{
                return errors.New("status is empty")
        }</span>
        <span class="cov8" title="1">path, err := s.runInfoPath(runID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return UpdateRunInfo(path, func(info *RunInfo) error </span><span class="cov8" title="1">{
                info.Status = status
                info.ExitCode = exitCode
                info.EndTime = s.now().UTC()
                return nil
        }</span>)
}

// GetRunInfo loads run metadata by run ID.
func (s *FileStorage) GetRunInfo(runID string) (*RunInfo, error) <span class="cov8" title="1">{
        if strings.TrimSpace(runID) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("run id is empty")
        }</span>
        <span class="cov8" title="1">path, err := s.runInfoPath(runID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info, err := ReadRunInfo(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "read run-info")
        }</span>
        <span class="cov8" title="1">return info, nil</span>
}

// ListRuns lists run metadata for a project task.
func (s *FileStorage) ListRuns(projectID, taskID string) ([]*RunInfo, error) <span class="cov8" title="1">{
        if strings.TrimSpace(projectID) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("project id is empty")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(taskID) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("task id is empty")
        }</span>
        <span class="cov8" title="1">baseDir := filepath.Join(s.root, projectID, taskID, "runs")
        entries, err := os.ReadDir(baseDir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "read runs directory")
        }</span>

        <span class="cov8" title="1">runs := make([]*RunInfo, 0, len(entries))
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">path := filepath.Join(baseDir, entry.Name(), "run-info.yaml")
                info, err := ReadRunInfo(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "read run-info for run %s", entry.Name())
                }</span>
                <span class="cov8" title="1">runs = append(runs, info)</span>
        }

        <span class="cov8" title="1">sort.Slice(runs, func(i, j int) bool </span><span class="cov8" title="1">{
                return runs[i].RunID &lt; runs[j].RunID
        }</span>)
        <span class="cov8" title="1">return runs, nil</span>
}

func (s *FileStorage) runInfoPath(runID string) (string, error) <span class="cov8" title="1">{
        if path, ok := s.lookupRun(runID); ok </span><span class="cov8" title="1">{
                return path, nil
        }</span>
        <span class="cov8" title="1">pattern := filepath.Join(s.root, "*", "*", "runs", runID, "run-info.yaml")
        matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "glob run-info path")
        }</span>
        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("run-info not found for run id %s", runID)
        }</span>
        <span class="cov8" title="1">if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("multiple run-info files found for run id %s", runID)
        }</span>
        <span class="cov0" title="0">s.trackRun(runID, matches[0])
        return matches[0], nil</span>
}

func (s *FileStorage) trackRun(runID, path string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.runIndex[runID] = path
}</span>

func (s *FileStorage) lookupRun(runID string) (string, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        path, ok := s.runIndex[runID]
        return path, ok
}</span>

func (s *FileStorage) newRunID() string <span class="cov8" title="1">{
        now := s.now().UTC()
        stamp := now.Format("20060102-150405000")
        return fmt.Sprintf("%s-%d", stamp, s.pid())
}</span>

var _ Storage = (*FileStorage)(nil)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
