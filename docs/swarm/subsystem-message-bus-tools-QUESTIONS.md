# Message Bus Tooling - Questions

- Q: What are the required header fields for each message entry, and what is the canonical msg_id format?
  Proposed default: Required: msg_id, ts, type, project; optional: task, run_id, parents[]; msg_id = ULID generated by run-agent bus tooling.
  A: Accepted.

- Q: Should tooling read legacy single-line entries, or require YAML front-matter only?
  Proposed default: Read both; new writes always YAML front-matter; provide optional migration tool.
  A: No need for backward compatibility, this is a new tool anyway. Use the right approach.

- Q: What is the exact concurrency/atomicity strategy for appending messages?
  Proposed default: Advisory file lock + append + fsync for new entries; temp+rename only for compaction.
  A: We base it on the run-agent logic, create a temp file first, next swap files. There is low change of conflict, use OS-provided features.

- Q: What ordering guarantees should bus readers assume when multiple agents append concurrently?
  Proposed default: Timestamp ordering only; ties resolved by msg_id; no global FIFO guarantee.
  A: the ID is timestamp + pid, so it's globally unique. Low probability of collision or conflicts is ok.

- Q: Should poll/pager support cursor persistence (e.g., --cursor-file) or leave it entirely to callers?
  Proposed default: Optional --cursor-file storing last msg_id; default caller-managed.
  A: No cursor file, it's up to the caller to manage it.

- Q: Are there message size limits and attachment conventions for large bodies?
  A: Soft limit 64KB; larger content stored in a file with attachment_path metadata.

- Q: Should task-level messages be mirrored into the project bus, or remain task-only with UI aggregation?
  A: No mirroring; UI aggregates project/task buses at read time.

- Q: How should corrections/updates to prior messages be represented (supersedes semantics)?
  Proposed default: Append-only new entry with supersedes[] referencing prior msg_id (same bus scope only); UI collapses superseded entries.
  A: Correction and updates form the thread for the previous message. use paretns[] to link them.

- Q: Should the bus support structured query (filter by type/run_id/date range) or only sequential read?
  Proposed default: Sequential read for MVP; tooling provides post-filter; structured index added later if needed.
  A: yes. sequential read + query/filter/regex which works in linear time, just scan all iterms and pick, no need for index so far.

- Q: What is the compaction/archival strategy for MESSAGE-BUS growth over time?
  Proposed default: Rotate on size threshold (e.g., 10MB); archive old chunks to MESSAGE-BUS-archive/<timestamp>.md; readers scan all chunks.
  A: No strategy yet. We let it grow infinetely for now.

- Q: What is the canonical method for agents to post messages (direct file append vs run-agent bus CLI vs library)?
  A: Use run-agent bus CLI (or library wrapper) only; direct file writes are disallowed.
