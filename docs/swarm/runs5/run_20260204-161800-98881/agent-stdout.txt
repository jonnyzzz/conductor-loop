Perfect! Now I have verified the external facts. Let me analyze the documentation and prepare my output.

## Review Output

### 1) External Facts Check

All external factual claims verified successfully:

- **Go's go:embed**: Confirmed. The `//go:embed` directive can embed a `dist` folder and entire directory trees into a Go binary. Example: `//go:embed dist/*` with `var webapp embed.FS`. [Source: Go Packages](https://pkg.go.dev/embed), [JetBrains Blog](https://blog.jetbrains.com/go/2021/06/09/how-to-use-go-embed-in-go-1-16/)

- **Vite for React + TypeScript**: Confirmed. Vite is a popular, fast build tool for React + TypeScript in 2026, with esbuild providing 20-30x faster transpilation than vanilla tsc. [Source: Vite.dev](https://vite.dev/), [Medium Guide 2026](https://medium.com/@robinviktorsson/complete-guide-to-setting-up-react-with-typescript-and-vite-2025-468f6556aaf2)

- **SSE vs WebSocket**: Confirmed. SSE provides simpler one-way server-to-client streaming over HTTP with automatic reconnection; WebSocket offers bidirectional communication with lower latency but more complexity. SSE is appropriate for the monitoring UI's server-to-client streaming use case. [Sources: Ably](https://ably.com/blog/websockets-vs-sse), [Svix](https://www.svix.com/resources/faq/websocket-vs-sse/), [SoftwareMill](https://softwaremill.com/sse-vs-websockets-comparing-real-time-communication-protocols/)]

- **HCL + Go**: Confirmed. HashiCorp Configuration Language has mature Go library support via `github.com/hashicorp/hcl/v2` with simple decoding interfaces (hclsimple, gohcl). [Source: GitHub](https://github.com/hashicorp/hcl), [Go Packages](https://pkg.go.dev/github.com/hashicorp/hcl/v2)]

### 2) TIPICS Updates

**Topic 9 decisions are minimal; expand with concrete details:**

- Add: Frontend bundler is Vite (fast dev with HMR, optimized production builds via esbuild).
- Add: Assets embedded using `go:embed dist` with `embed.FS` type.
- Add: UI dev workflow uses separate dev server with proxy to Go backend for development; embedded assets for release.
- Add: State management via React Context + hooks (no Redux/Zustand for MVP).
- Add: Go build uses standard `go build` with embedded UI assets; UI built separately via `npm run build` (Vite).

**Topic 9 open questions need refinement:**

- Current question "Build workflow for UI assets (Vite vs other)" can be resolved → Decision: Vite.
- Current question "embedding (go:embed vs external)" can be resolved → Decision: go:embed.
- Keep open: API contract/schema definition and TypeScript type generation strategy (OpenAPI vs manual sync).
- Add open: UI test framework (Vitest, Jest, or none for MVP).

**Related topics needing alignment:**

- Topic 10 (Frontend-Backend API Contract) should reference TypeScript type generation question from Topic 9.

### 3) Spec Updates

**subsystem-runner-orchestration.md:**
- Line 60 "Config file format: HCL (Hashicorp)" → Add note: "parsed via github.com/hashicorp/hcl/v2/hclsimple"
- Add section "Build & Distribution": Single Go binary built with `go build`, includes embedded UI assets via go:embed, supports all major platforms (linux/darwin/windows).

**subsystem-monitoring-ui.md:**
- Add section "Build Tooling": 
  - Frontend: Vite for dev + build; TypeScript + React + React Context for state
  - Dev workflow: `npm run dev` starts Vite dev server with proxy to `run-agent serve`
  - Production: `npm run build` outputs to `ui/dist`, embedded via `//go:embed ui/dist` in Go binary
- Line 4 "embedded static assets" → specify: "via go:embed of ui/dist folder"
- Add to "Data Sources" section: API contract is REST/JSON + SSE events (schema TBD)
- Add note under "Performance": Vite provides Fast Refresh/HMR for sub-50ms updates during development

### 4) Questions to Remove/Resolve

**subsystem-monitoring-ui-QUESTIONS.md:**

- Q: "Which build tool should be used for the TypeScript + React UI (Vite, CRA, custom)?" 
  - **Resolution**: Vite selected for fast dev (HMR via esbuild) and optimized builds. CRA is deprecated/legacy; Vite is industry standard in 2026.
  
- Q: "How are frontend assets embedded into the Go binary (go:embed vs external assets)?"
  - **Resolution**: Use `go:embed ui/dist` with `embed.FS` type; proven pattern for Go web apps since Go 1.16.
  
- Q: "What is the development workflow for the UI (separate dev server with proxy vs embedded only)?"
  - **Resolution**: Separate Vite dev server with proxy to Go backend for development; embedded for release builds. Standard pattern for Go + SPA.
  
- Q: "Do we need a state management library (Redux/Zustand) or is React Context sufficient for MVP?"
  - **Resolution**: React Context + hooks sufficient for MVP. UI is read-only with simple tree/message/output views; Redux adds unnecessary complexity.

**subsystem-runner-orchestration-QUESTIONS.md:**

- Q: "How are run-agent binary updates/versioning handled in the Go implementation (manual install vs self-update)?"
  - **No change**: Keep as open question for post-MVP; manual install/rebuild is MVP decision.
  
- Q: "Where is the config.hcl schema/version defined and validated?"
  - **Clarify**: Change to "Where is the config.hcl schema defined, how is it validated, and how are schema migrations handled across versions?" Proposed default: Embed schema in Go structs with validation on startup; defer migration strategy to post-MVP.

### 5) New Open Questions

**subsystem-monitoring-ui-QUESTIONS.md:**

- **Q**: What is the API contract between the Go backend and the UI (REST endpoint schemas, SSE event formats), and how are TypeScript types generated or synchronized?
  - **Proposed default**: Define REST endpoints with inline comments or simple OpenAPI annotations; generate TypeScript types via tool (e.g., oapi-codegen, quicktype) or maintain manually in MVP.
  - **A**: TBD.

- **Q**: Should the UI include tests, and if so, which framework (Vitest, Jest, React Testing Library)?
  - **Proposed default**: Defer to post-MVP; focus on functional implementation first.
  - **A**: TBD.

- **Q**: What CSS framework or styling approach should be used (Tailwind, CSS Modules, styled-components, vanilla CSS)?
  - **Proposed default**: CSS Modules or vanilla CSS for MVP to minimize dependencies; JetBrains Mono font already decided.
  - **A**: TBD.

**subsystem-runner-orchestration-QUESTIONS.md:**

- **Q**: What is the Go module structure for the run-agent binary (monorepo with subpackages vs flat structure)?
  - **Proposed default**: Flat structure with subpackages (cmd/run-agent, internal/runner, internal/ui, internal/bus, internal/config) for organization.
  - **A**: TBD.

- **Q**: Should the Go binary support multiple platforms at build time, and which targets (linux-amd64, darwin-amd64, darwin-arm64, windows-amd64)?
  - **Proposed default**: Cross-compile for linux-amd64, darwin-amd64, darwin-arm64 as primary targets; windows-amd64 optional.
  - **A**: TBD.

---

**Summary**: Topic 9 had many implicit decisions that should be made explicit. The main resolutions are: Vite for UI build, go:embed for asset embedding, separate dev server with proxy, and React Context for state. The API contract and type generation strategy remains the key open question connecting Topics 9 and 10.
