# Architecture & Core Design Facts

Extracted from: THE_PLAN_v5.md, ARCHITECTURE-REVIEW-SUMMARY.md, DEPENDENCY_ANALYSIS.md,
IMPLEMENTATION-README.md, docs/decisions/*, docs/dev/architecture.md,
docs/dev/ralph-loop.md, docs/dev/subsystems.md, and swarm legacy docs.

Author: Eugene Petrenko (eugene.petrenko@jetbrains.com)

---

## System Identity

[2026-02-04 23:03:05] [tags: architecture, identity]
Conductor Loop is a Go multi-agent orchestration framework that coordinates multiple AI agents (Claude, Codex, Gemini, Perplexity, xAI) to work together on software tasks. Core design: Ralph Loop architecture with file-based message passing, hierarchical run management, and optional web-based monitoring UI.

[2026-02-04 23:34:11] [tags: architecture, binaries]
Single-binary design: `run-agent` is the official entry point for everything — task execution, job submission, filesystem queries, and optional monitoring server. The `conductor` binary is a deprecated pass-through alias to `run-agent`.

[2026-02-20 22:24:09] [tags: architecture, statistics]
Backend: ~12,000 lines of Go code, 64+ test files. Frontend (primary): React 18 + TypeScript in `frontend/`. Frontend (fallback): Vanilla JavaScript in `web/src/`, no build step. Dependencies intentionally minimal: Cobra, YAML v3, pkg/errors.

---

## Offline-First Design Principles (Non-Negotiable Invariants)

[2026-02-21 11:45:48] [tags: architecture, offline-first]
INVARIANT 1: `run-agent` is the only required binary. Every capability accessible through it.

[2026-02-21 11:45:48] [tags: architecture, offline-first, storage]
INVARIANT 2: Each `run-agent` process is fully independent. Task execution requires only the filesystem — no database, no coordinator process, no shared memory. Multiple processes can run concurrently with zero inter-process coordination. File locking (flock) prevents corruption on shared files.

[2026-02-21 11:45:48] [tags: architecture, offline-first, server]
INVARIANT 3: `run-agent serve` is optional — monitoring only. If killed, all running agent processes continue unaffected. The message bus, DONE file mechanism, and run completion all work without the server. Server can be started at any time to inspect past or in-progress runs.

[2026-02-21 11:45:48] [tags: architecture, offline-first, conductor-url]
INVARIANT 4: `CONDUCTOR_URL` is informational only. Injected into spawned agent processes as convenience for posting messages. The runner itself NEVER calls back to the server.

[2026-02-21 11:45:48] [tags: architecture, offline-first, storage]
INVARIANT 5: The filesystem is the single source of truth. No in-process state is authoritative. The API server re-reads from disk on every request. Prometheus counters (in-memory) are the only purely transient state.

---

## Storage Layout

[2026-02-04 23:03:05] [tags: architecture, storage, layout]
Directory structure: `<root>/<project_id>/<task_id>/runs/<run_id>/`. Files: `TASK.md` (task prompt), `DONE` (completion marker), `TASK-MESSAGE-BUS.md` (append-only event log), `runs/<run_id>/run-info.yaml` (metadata), `runs/<run_id>/agent-stdout.txt` (agent output), `runs/<run_id>/output.md` (final output).

[2026-02-04 23:03:05] [tags: architecture, storage, run-info]
RunInfo YAML schema fields: run_id, project_id, task_id, agent_type, pid, pgid, status (running/success/failed/stopped), start_time, end_time, exit_code, error_summary (omitempty), agent_version (omitempty).

[2026-02-04 23:03:05] [tags: architecture, storage, run-id]
RunID format: `{YYYYMMDD-HHMMSSmmm}-{PID}`. Generated by FileStorage.newRunID() using millisecond timestamp + PID. Example: `20260205-150405123-12345`. (Distinct from message IDs which use different format.)

[2026-02-04 23:03:05] [tags: architecture, storage, atomic-write]
Atomic write pattern for run-info.yaml: (1) Write to temp file `run-info.yaml.tmp.{pid}` in same directory, (2) fsync to ensure durability, (3) rename to `run-info.yaml`. Rename is atomic on POSIX. Readers always see complete, valid YAML. Performance: ~5-10ms per write.

[2026-02-04 23:03:05] [tags: architecture, storage, index]
In-memory run index: `map[string]string` (RunID → path), protected by `sync.RWMutex`. Populated on CreateRun and on-demand during lookups. Lookup strategy: check index first, then glob `{root}/*/*/runs/{runID}/run-info.yaml`. Index not persisted; rebuilt on restart.

---

## Message Bus

[2026-02-04 23:03:05] [tags: architecture, message-bus, concurrency]
DECISION (Problem #1): Message bus uses O_APPEND + flock with fsync-always policy. Exclusive write lock (flock, 10s timeout). Lockless reads — readers never block writers. fsync after every write for crash safety. Throughput: ~37,000+ writes/sec measured with 10 concurrent writers.

[2026-02-04 23:03:05] [tags: architecture, message-bus, msg-id]
Message ID format: `MSG-{YYYYMMDD-HHMMSS}-{NANOSECONDS}-PID{PID}-{SEQUENCE}`. Example: `MSG-20060102-150405-000000001-PID00123-0042`. Properties: lexically sortable, globally unique (timestamp + PID + sequence), human-readable. Atomic counter (sync/atomic.AddUint32) within process.

[2026-02-04 23:03:05] [tags: architecture, message-bus, collision]
DECISION (Problem #4): msg_id collision resolved by multi-layer uniqueness: nanosecond precision (1B IDs/sec/process), PID (distinguishes processes), atomic sequence counter (same-nanosecond). Edge cases handled: PID wraparound (nanosecond prevents collision), clock skew (IDs still unique via PID+nano+seq), rapid CLI calls (each has unique PID).

[2026-02-04 23:03:05] [tags: architecture, message-bus, format]
File format: YAML with document separators (`---`). Header contains msg_id, ts, type, project_id, task_id, run_id, parents (for threading). Body is free-text after second `---`. Parser uses state machine: stateSeekHeader → stateHeader → stateBody.

[2026-02-04 23:03:05] [tags: architecture, message-bus, symlink]
Security: symlink check required before opening message bus file. Callers responsible for retry logic on lock timeout. Windows behavior: mandatory locks may block concurrent reads (documented limitation).

[2026-02-20 13:12:04] [tags: architecture, message-bus, rotation]
Bus file growth management: `WithAutoRotate(maxBytes)` option or `run-agent gc --rotate-bus`. SSE streams handle bus rotation: ErrSinceIDNotFound resets lastID to "" and re-reads from start.

[2026-02-04 23:03:05] [tags: architecture, message-bus, performance]
Poll path for SSE: PollForNew() loops with ReadMessages(lastID); if empty, sleep 200ms, then retry. SSE streams poll every 100ms (configurable). Heartbeat every 30s. Max 10 concurrent clients per run (configurable).

---

## Ralph Loop (Root Agent Loop Process Handler)

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, algorithm]
Ralph Loop algorithm: (1) Check DONE file BEFORE starting agent. If DONE exists → handle children/completion. (2) Check max restarts (default 100). (3) Run agent process. (4) Check DONE file AFTER agent exits. (5) If not done → delay 1s → restart. Exit conditions (no restart): exit code 0, DONE file detected, max restarts exceeded, fatal error, context canceled, wait-without-restart signal.

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, defaults]
Ralph Loop default constants: maxRestarts=100, waitTimeout=300s (5 minutes), pollInterval=1s, restartDelay=1s. All configurable via WithMaxRestarts, WithWaitTimeout, WithPollInterval, WithRestartDelay options.

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, done-children]
DECISION (Problem #2): When DONE exists AND children are running: WAIT (do NOT restart root). Wait up to 300s (configurable child_wait_timeout). Detect children via run-info.yaml (empty end_time + non-empty parent_run_id) + `kill(-pgid, 0)` check. Poll every 1s. On timeout: log WARNING to message bus with orphaned run IDs, proceed to completion. Do NOT kill orphaned children. Rationale: DONE means root declared completion; restarting is a wasteful no-op.

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, agent-patterns]
Two valid agent delegation patterns: Pattern A (Parallel with Aggregation) — root waits for children before writing DONE. Pattern B (Fire-and-Forget) — root writes DONE immediately after spawning, Ralph loop waits for children. Anti-pattern: root writes DONE expecting restart for aggregation (wrong — use Pattern A instead).

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, done-file]
DONE file location: `{task_dir}/DONE`. Created by agent via `touch $TASK_FOLDER/DONE`. Detected by `os.Stat()` — presence is enough, no read required. Post-detection: completion fact propagation worker runs (best-effort, non-fatal on failure), posts synthesized FACT to PROJECT-MESSAGE-BUS.md.

[2026-02-04 23:03:05] [tags: architecture, ralph-loop, error-classification]
Fatal errors (no restart): executable not found (exec.ErrNotFound), permission denied (os.IsPermission), invalid configuration (ErrInvalidConfig). Transient errors: network timeout, rate limits → restart. Context errors: context.Canceled → stop.

---

## Process Management

[2026-02-04 23:03:05] [tags: architecture, process, detach]
DECISION (Problem #7): "Detach" means setsid() (new process group/session), NOT daemonization. Effect: child detaches from controlling terminal, won't receive SIGINT/SIGHUP, but parent can still waitpid(). Implementation: `cmd.SysProcAttr = &syscall.SysProcAttr{Setsid: true}`. Child's parent remains runner (not init/PID 1).

[2026-02-04 23:03:05] [tags: architecture, process, pgid]
DECISION: Process groups (PGID) for child tracking. Setpgid=true creates new process group with PGID=PID. Kill entire tree: `syscall.Kill(-pgid, syscall.SIGTERM)` then wait 5s then `syscall.SIGKILL`. Windows: no process group support; recommend WSL2. Children detected via `kill(-pgid, 0)` — returns nil if alive, ESRCH if dead, EPERM if alive but unpermitted.

[2026-02-04 23:03:05] [tags: architecture, process, run-id-collision]
RunID generation bug (fixed in Session #38): run ID collision in runner.newRunID() caused Scenario3 acceptance test failure. Fixed: `28b6ca1`.

---

## Configuration System

[2026-02-04 23:03:05] [tags: architecture, config]
Config structure: Agents (map[string]AgentConfig), Defaults (default agent + timeout), API (host/port/SSE settings), Storage (runs_dir). YAML format (.yaml/.yml) and HCL (.hcl) both supported.

[2026-02-04 23:03:05] [tags: architecture, config, tokens]
Token resolution precedence: (1) direct `token` field, (2) `token_file` field (read from file), (3) env var `AGENT_{TYPE}_TOKEN`. Env vars: AGENT_CLAUDE_TOKEN, AGENT_CODEX_TOKEN, AGENT_GEMINI_TOKEN, AGENT_PERPLEXITY_TOKEN, AGENT_XAI_TOKEN. Token/token_file are mutually exclusive. `cli_flags` and `env_var` fields removed from schema (hardcoded per agent type in runner).

[2026-02-04 23:03:05] [tags: architecture, config, loading]
LoadConfig: full validation including token resolution. LoadConfigForServer: lenient — skips token validation (steps 8-9). Used for API server startup where agent execution may be disabled. No hot-reloading — restart required for config changes.

---

## Agent Protocol

[2026-02-04 23:03:05] [tags: architecture, agent-protocol]
Agent interface: `Execute(ctx context.Context, runCtx *RunContext) error` + `Type() string`. RunContext fields: RunID, ProjectID, TaskID, Prompt, WorkingDir, StdoutPath, StderrPath, Environment (map). Agents redirect stdout/stderr to files, change to WorkingDir, merge Environment with os.Environ().

[2026-02-04 23:03:05] [tags: architecture, agent-protocol, output]
DECISION (Problem #5): Unified output.md rule — agents SHOULD write output.md (best-effort). If output.md does not exist after agent exits, runner MUST create it from agent-stdout.txt (fallback). Applies to all backends: Claude, Codex, Gemini, Perplexity, xAI. This rule was added to all 5 backend specs.

[2026-02-04 23:03:05] [tags: architecture, agent-protocol, perplexity]
DECISION (Problem #6): Perplexity backend writes ONLY to stdout (streaming), no double-write. Runner creates output.md from stdout if needed. Citations included in stdout stream. Consistent with Claude/Codex/Gemini backends.

---

## Agent Backends

[2026-02-04 23:03:05] [tags: architecture, backends]
Supported agent backends: Claude (CLI invocation, ANTHROPIC_API_KEY env), Codex (OpenAI-compatible API, OPENAI_API_KEY), Gemini (Google Gemini API, GEMINI_API_KEY), Perplexity (REST + SSE, PERPLEXITY_API_KEY), xAI/Grok (deferred post-MVP, XAI_API_KEY). Each implements Agent interface in `internal/agent/<backend>/`.

[2026-02-04 23:03:05] [tags: architecture, backends, gemini]
Gemini streaming verified experimentally: progressive stdout streaming, ~1s chunk intervals, compatible with `--screen-reader true` flag.

[2026-02-04 23:03:05] [tags: architecture, backends, perplexity]
Perplexity streaming: SSE via `stream=True` parameter. All models support streaming. Citations arrive at end of stream.

---

## API Server

[2026-02-04 23:03:05] [tags: architecture, api]
REST API categories: Projects (list, details), Tasks (list, create, details, file), Runs (info, file with tail, stop), Message Bus (read/write, SSE stream), Logs (SSE stream). DELETE endpoints for runs (204) and tasks (204). 409 Conflict if running. 403 Forbidden for browser-originated destructive requests.

[2026-02-04 23:03:05] [tags: architecture, api, sse]
DECISION (Problem #8): SSE run discovery uses 1-second interval polling of runs/ directory. Rationale: simpler and more robust than inotify/FSEvents for MVP. Avoids filesystem watcher complexity. SSE heartbeat every 30s to keep connection alive. Max clients per run: 10 (configurable).

[2026-02-04 23:03:05] [tags: architecture, api, no-auth]
API has no authentication (open, secured via network). No rate limiting. No pagination. SSE only (unidirectional; REST for commands).

[2026-02-20 23:02:34] [tags: architecture, api, path-resolution]
Path resolution helpers `findProjectDir` and `findProjectTaskDir` in `internal/api/handlers_projects.go` support multiple directory layouts (checks direct path, `runs/` subdirectory, walks up to 3 levels). Allows API to work regardless of whether root is set to repo root or `runs/` subdirectory.

[2026-02-23 07:12:05] [tags: architecture, api, metrics]
Prometheus /metrics endpoint: GET /metrics returns uptime, active/completed/failed runs, api_requests_total in Prometheus format. In-memory counters only — not persisted. Added Session #42.

---

## Environment Variables (Agent Execution)

[2026-02-04 23:03:05] [tags: architecture, env, agent]
JRUN_* variables injected into agent environment: JRUN_PROJECT_ID, JRUN_TASK_ID, JRUN_ID (run identifier), JRUN_PARENT_ID (parent run ID if sub-agent). Also: TASK_FOLDER (absolute path to task directory containing TASK.md), RUN_FOLDER (absolute path to current run directory for output.md), MESSAGE_BUS (absolute path to TASK-MESSAGE-BUS.md), CONDUCTOR_URL (monitoring server URL, informational only).

---

## Frontend UI

[2026-02-20 23:02:34] [tags: architecture, ui]
Two UIs: (1) React 18 + TypeScript in `frontend/` (primary, requires `npm run build`, output to `frontend/dist/`); (2) Vanilla JS in `web/src/` (fallback, no build step). Server serves React if `frontend/dist/index.html` exists, else falls back to `web/src/`. Delete or move `frontend/dist/` to force fallback.

[2026-02-21 02:01:38] [tags: architecture, ui, features]
UI features: task list with search bar (client-side substring filter), run detail tabs (TASK.md / OUTPUT / STDOUT / STDERR / RUN-INFO / MESSAGES), project message bus live stream (SSE), stop button (POST .../stop), message posting form, auto-refresh every 5s. ProjectStats dashboard shows total_tasks, total_runs, running_runs, completed_runs, failed_runs+crashed_runs, message_bus_total_bytes.

---

## Key Design Decisions Summary

[2026-02-04 23:03:05] [tags: architecture, decisions-summary]
Concurrency control: O_APPEND + flock (POSIX atomic append). File updates: temp + rename (atomic replacement). Process management: setsid() for terminal detachment + PGID for tree kill. ID generation: nano + PID + counter (multi-layer uniqueness). Output handling: runner fallback guarantees output.md exists. Backend uniformity: stdout-only (consistent interface). Run discovery: 1s polling (cross-platform simplicity).

[2026-02-04 23:17:00] [tags: architecture, decisions-summary, rationale]
File-based storage over database: simple (no setup), portable, debuggable with standard tools, atomic ops via rename. YAML over JSON: human-readable for debugging, comments supported, gopkg.in/yaml.v3 available. SSE over WebSockets: simpler (HTTP-based, no protocol upgrade), sufficient (unidirectional), automatic reconnection.

[2026-02-04 23:03:05] [tags: architecture, windows]
Windows compatibility: partial. Message bus: mandatory locks block readers (limitation). Process groups: not supported natively (no PGID, no kill(-pgid,0)). Recommendation: WSL2. O_APPEND atomicity not guaranteed on network filesystems (local storage only). Native Windows support marked experimental.

---

## Subsystem Dependency Graph

[2026-02-04 23:17:00] [tags: architecture, dependencies]
7-layer dependency DAG (no circular dependencies): Layer 0: Storage + Config (no deps). Layer 1: Message Bus (→ Storage). Layer 2: Agent Protocol (→ Storage, Message Bus). Layer 3: Agent Backends (→ Agent Protocol, Config). Layer 4: Runner Orchestration (→ Storage, Message Bus, Config, Agent Protocol, Agent Backends). Layer 5: API Server (→ Storage, Message Bus, Runner). Layer 6: Frontend UI (→ API Server). Critical path: Storage → Message Bus → Runner (30h sequential, the longest path in original planning).

[2026-02-04 23:17:00] [tags: architecture, subsystems, count]
Originally 8 core subsystems. Extended to 16 by Session #32: added CLI run-agent list (#10), run-agent output (#11), run-agent watch (#12), DELETE run endpoint (#13), UI task search bar (#14), task deletion endpoint (#15), UI project stats dashboard (#16).

---

## Implementation Phases (Original Plan, 2026-02-04)

[2026-02-04 23:03:05] [tags: architecture, phases]
Phase 0: Bootstrap (parallel: project structure, docs, tooling, arch review). Phase 1: Core infrastructure (storage, config, message bus). Phase 2a: Agent protocol (sequential). Phase 2b: Agent backends (parallel). Phase 3: Runner orchestration (sequential — most complex, 30h). Phase 4a: API (parallel REST+SSE). Phase 4b: UI (sequential after API). Phase 5: Integration testing. Phase 6: Documentation. Total: ~106h. Critical path: Phase 3 Runner Orchestration.

[2026-02-04 23:34:11] [tags: architecture, phases, arch-review]
Architecture review (bootstrap-04) assessed implementation readiness at 70-75% initially (8 critical blockers). After resolving all 8 problems: 95%+ ready. Phase ordering corrections: agent backends must follow agent protocol (not parallel from start); UI must follow API (or accept higher risk with frozen spec + integration tests).

---

## Critical Problems Resolved (2026-02-04)

[2026-02-04 23:03:05] [tags: architecture, problems, #1]
Problem #1 APPROVED: Message bus race condition → O_APPEND + flock + fsync. Lockless reads. 10s lock timeout. Callers responsible for retry. Symlink security check required.

[2026-02-04 23:03:05] [tags: architecture, problems, #2]
Problem #2 APPROVED: Ralph Loop DONE + running children → Wait Without Restart (not restart). 300s timeout. PGID-based child detection. On timeout: warn + proceed (don't kill orphans).

[2026-02-04 23:03:05] [tags: architecture, problems, #3]
Problem #3 SOLVED: run-info.yaml update race → Atomic rewrite (temp + fsync + rename). <1ms overhead.

[2026-02-04 23:03:05] [tags: architecture, problems, #4]
Problem #4 SOLVED (by #1): msg_id collision → Nano+PID+sequence format. Negligible collision probability.

[2026-02-04 23:03:05] [tags: architecture, problems, #5]
Problem #5 SOLVED: output.md creation responsibility → Runner fallback (guaranteed existence from stdout). Agents encouraged but not required.

[2026-02-04 23:03:05] [tags: architecture, problems, #6]
Problem #6 SOLVED: Perplexity double-write → stdout-only (like all other backends). Runner creates output.md if needed.

[2026-02-04 23:03:05] [tags: architecture, problems, #7]
Problem #7 CLARIFIED: Process detachment is setsid() not daemonization. Parent can still waitpid(). Not a bug.

[2026-02-04 23:03:05] [tags: architecture, problems, #8]
Problem #8 SOLVED: SSE run discovery → 1-second polling of runs/ directory. Simpler than inotify/FSEvents, cross-platform.

---

## Performance Characteristics

[2026-02-04 23:03:05] [tags: architecture, performance]
Message bus: write <0.1ms (OS-cached, no fsync), read ~0.1-1ms (lockless), throughput ~37,000+ writes/sec (10 concurrent writers). Storage: CreateRun ~5-10ms, GetRunInfo ~0.1-1ms (index), ListRuns ~1-10ms. API: request ~1-5ms, SSE ~100ms latency. Ralph Loop: restart delay 1s, DONE file poll 1s. Scaling limits: 100+ concurrent tasks, 50+ agents (lock contention), ~1GB message bus before rotation needed.

---

## Session History (Architecture Milestones)

[2026-02-05 17:28:15] [tags: architecture, history]
Session completing Stage 6: Comprehensive developer/user documentation written. ralph-loop.md, subsystems.md, architecture.md created.

[2026-02-20 13:12:04] [tags: architecture, history]
Inaccuracies fixed in architecture.md, message-bus docs, ralph-loop.md. Documented that ralph-loop checks DONE file BEFORE running agent (not only after).

[2026-02-21 11:45:48] [tags: architecture, history]
Offline-first design principles added to architecture.md as non-negotiable architectural invariants. Server declared optional monitoring layer.

[2026-02-23 07:12:05] [tags: architecture, history]
feat(core): ship task orchestration, self-update, and web UI reliability improvements. Latest known good state: all tests pass, acceptance scenarios 1-4 pass.
